<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Attention to Number Test Generator</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: Arial, sans-serif;
            padding: 20px;
            background-color: #f5f5f5;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 30px;
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
            padding: 20px;
            background: #f9f9f9;
            border-radius: 8px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        label {
            font-weight: bold;
            color: #555;
            font-size: 14px;
        }

        select, input[type="number"], input[type="color"] {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }

        /* Custom select styling with previews */
        .select-with-preview {
            position: relative;
        }

        .select-wrapper {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .select-preview {
            width: 35px;
            height: 35px;
            border: 2px solid #333;
            border-radius: 4px;
            flex-shrink: 0;
            background: white;
        }

        .select-wrapper select {
            flex: 1;
        }

        button {
            padding: 12px 24px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: background-color 0.3s;
        }

        button:hover {
            background-color: #45a049;
        }

        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }

        .action-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-bottom: 30px;
        }

        #downloadBtn {
            background-color: #2196F3;
        }

        #downloadBtn:hover {
            background-color: #0b7dda;
        }

        #testCanvas {
            border: 2px solid #ddd;
            display: block;
            margin: 0 auto;
            background: white;
            border-radius: 8px;
            max-width: 100%;
            height: auto;
        }

        .info {
            text-align: center;
            color: #666;
            margin-top: 20px;
            font-size: 14px;
        }

        .test-type-selector {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            justify-content: center;
        }

        .test-type-btn {
            padding: 10px 20px;
            background-color: #e0e0e0;
            color: #333;
            border: 2px solid transparent;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
        }

        .test-type-btn.active {
            background-color: #4CAF50;
            color: white;
            border-color: #45a049;
        }

        .hidden {
            display: none;
        }

        /* Modal Styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.4);
        }

        .modal.show {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-content {
            background-color: #fefefe;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            max-width: 600px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            border-bottom: 2px solid #ddd;
            padding-bottom: 15px;
        }

        .modal-header h2 {
            margin: 0;
            color: #333;
        }

        .close {
            color: #aaa;
            font-size: 32px;
            font-weight: bold;
            cursor: pointer;
            line-height: 1;
        }

        .close:hover,
        .close:focus {
            color: #000;
        }

        .config-section {
            margin-bottom: 25px;
        }

        .config-section h3 {
            color: #555;
            margin-bottom: 15px;
            font-size: 18px;
            border-bottom: 1px solid #eee;
            padding-bottom: 8px;
        }

        .config-item {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
            gap: 15px;
        }

        .config-item label {
            flex: 1;
            font-weight: normal;
            color: #666;
            font-size: 14px;
        }

        .config-item input[type="number"] {
            width: 100px;
            padding: 6px 10px;
        }

        .config-item .unit {
            color: #999;
            font-size: 13px;
            width: 40px;
        }

        .modal-actions {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
            margin-top: 25px;
            padding-top: 20px;
            border-top: 2px solid #ddd;
        }

        .modal-actions button {
            padding: 10px 20px;
            font-size: 14px;
        }

        .btn-secondary {
            background-color: #6c757d;
        }

        .btn-secondary:hover {
            background-color: #5a6268;
        }

        .btn-danger {
            background-color: #dc3545;
        }

        .btn-danger:hover {
            background-color: #c82333;
        }

        .config-button {
            background-color: #6c757d;
            margin-right: 10px;
        }

        .config-button:hover {
            background-color: #5a6268;
        }

        .info-icon {
            display: inline-block;
            width: 18px;
            height: 18px;
            background-color: #4ECDC4;
            color: white;
            border-radius: 50%;
            text-align: center;
            line-height: 18px;
            font-size: 12px;
            font-weight: bold;
            cursor: help;
            margin-left: 5px;
            position: relative;
        }

        .info-icon:hover::after {
            content: attr(data-tooltip);
            position: absolute;
            left: 25px;
            top: 50%;
            transform: translateY(-50%);
            background-color: #333;
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            white-space: nowrap;
            z-index: 1000;
            font-size: 13px;
            font-weight: normal;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }

        .info-icon:hover::before {
            content: '';
            position: absolute;
            left: 20px;
            top: 50%;
            transform: translateY(-50%);
            border: 5px solid transparent;
            border-right-color: #333;
            z-index: 1001;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Attention to Number Test Generator</h1>
        


        <div class="controls">
            <div class="control-group">
                <label for="targetType">Target Type:</label>
                <select id="targetType">
                    <option value="shape">Shape</option>
                    <option value="fruit">Fruit</option>
                </select>
            </div>

            <div class="control-group">
                <label for="targetCount">Target Count:</label>
                <select id="targetCount">
                    <option value="2">2</option>
                    <option value="3">3</option>
                    <option value="4" selected>4</option>
                    <option value="5">5</option>
                    <option value="6">6</option>
                </select>
            </div>

            <div class="control-group select-with-preview" id="shapeGroup">
                <label for="targetShape">Target Shape:</label>
                <div class="select-wrapper">
                    <canvas id="shapePreview" width="35" height="35" class="select-preview"></canvas>
                    <select id="targetShape">
                        <option value="circle">‚ö´ Circle</option>
                        <option value="square">‚¨õ Square</option>
                        <option value="triangle">‚ñ≤ Triangle</option>
                        <option value="rectangle">‚ñ¨ Rectangle</option>
                        <option value="star">‚òÖ Star</option>
                    </select>
                </div>
            </div>

            <div class="control-group select-with-preview hidden" id="fruitGroup">
                <label for="targetFruit">Target Fruit:</label>
                <div class="select-wrapper">
                    <canvas id="fruitPreview" width="35" height="35" class="select-preview"></canvas>
                    <select id="targetFruit">
                        <option value="apple">üçé Apple</option>
                        <option value="pear">üçê Pear</option>
                        <option value="orange">üçä Orange</option>
                        <option value="banana">üçå Banana</option>
                        <option value="cherry">üçí Cherry</option>
                    </select>
                </div>
            </div>

            <div class="control-group select-with-preview" id="colorGroup">
                <label for="targetColor">Target Color:</label>
                <div class="select-wrapper">
                    <canvas id="colorPreview" width="35" height="35" class="select-preview"></canvas>
                    <select id="targetColor">
                        <option value="#FF6B35">üü† Orange</option>
                        <option value="#4ECDC4">üî∑ Teal</option>
                        <option value="#FFD93D">üü° Yellow</option>
                        <option value="#A855F7">üü£ Purple</option>
                        <option value="#3B82F6">üîµ Blue</option>
                        <option value="#EF4444">üî¥ Red</option>
                    </select>
                </div>
            </div>

            <div class="control-group select-with-preview">
                <label for="targetPattern">Target Pattern:</label>
                <div class="select-wrapper">
                    <canvas id="patternPreview" width="35" height="35" class="select-preview"></canvas>
                    <select id="targetPattern">
                        <option value="solid">‚ñà Solid</option>
                        <option value="striped">‚ñí Striped</option>
                        <option value="dotted">‚®ø Dotted</option>
                        <option value="grid">‚ñ¶ Grid</option>
                        <option value="fullrandom" id="fullrandomOption" class="hidden">üé≤ Full Random</option>
                    </select>
                </div>
            </div>

        </div>

        <div class="action-buttons">
            <button id="configBtn" class="config-button">‚öôÔ∏è Spacing Configuration</button>
            <button id="generateBtn">Generate Test</button>
            <button id="downloadBtn">Download as PNG</button>
        </div>

        <canvas id="testCanvas" width="1600" height="900"></canvas>

        <div class="info">
            <p>The test includes a target and 4 choices. Only one choice will match based on the selected test type.</p>
        </div>
    </div>

    <!-- Spacing Configuration Modal -->
    <div id="configModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Spacing Configuration</h2>
                <span class="close">&times;</span>
            </div>
            
            <div class="config-section">
                <h3>Shape Spacing (by shape type)</h3>
                
                <h4 style="color: #777; font-size: 15px; margin-top: 15px; margin-bottom: 10px;">‚ö´ Circle</h4>
                <div class="config-item">
                    <label>Gap horizontal:<span class="info-icon" data-tooltip="Horizontal spacing between shapes in the same row (left-right)">‚Ñπ</span></label>
                    <input type="number" id="circle_gapH" min="0" max="200" step="5" value="60">
                    <span class="unit">px</span>
                </div>
                <div class="config-item">
                    <label>Gap vertical:<span class="info-icon" data-tooltip="Vertical spacing between shapes in different rows (top-bottom)">‚Ñπ</span></label>
                    <input type="number" id="circle_gapV" min="0" max="200" step="5" value="60">
                    <span class="unit">px</span>
                </div>
                <div class="config-item">
                    <label>Padding:<span class="info-icon" data-tooltip="Space between the shapes and the box edges">‚Ñπ</span></label>
                    <input type="number" id="circle_padding" min="0" max="100" step="5" value="45">
                    <span class="unit">px</span>
                </div>
                
                <h4 style="color: #777; font-size: 15px; margin-top: 15px; margin-bottom: 10px;">‚¨õ Square</h4>
                <div class="config-item">
                    <label>Gap horizontal:<span class="info-icon" data-tooltip="Horizontal spacing between shapes in the same row (left-right)">‚Ñπ</span></label>
                    <input type="number" id="square_gapH" min="0" max="200" step="5" value="60">
                    <span class="unit">px</span>
                </div>
                <div class="config-item">
                    <label>Gap vertical:<span class="info-icon" data-tooltip="Vertical spacing between shapes in different rows (top-bottom)">‚Ñπ</span></label>
                    <input type="number" id="square_gapV" min="0" max="200" step="5" value="60">
                    <span class="unit">px</span>
                </div>
                <div class="config-item">
                    <label>Padding:<span class="info-icon" data-tooltip="Space between the shapes and the box edges">‚Ñπ</span></label>
                    <input type="number" id="square_padding" min="0" max="100" step="5" value="45">
                    <span class="unit">px</span>
                </div>
                
                <h4 style="color: #777; font-size: 15px; margin-top: 15px; margin-bottom: 10px;">‚ñ≤ Triangle</h4>
                <div class="config-item">
                    <label>Gap horizontal:<span class="info-icon" data-tooltip="Horizontal spacing between shapes in the same row (left-right)">‚Ñπ</span></label>
                    <input type="number" id="triangle_gapH" min="0" max="200" step="5" value="60">
                    <span class="unit">px</span>
                </div>
                <div class="config-item">
                    <label>Gap vertical:<span class="info-icon" data-tooltip="Vertical spacing between shapes in different rows (top-bottom)">‚Ñπ</span></label>
                    <input type="number" id="triangle_gapV" min="0" max="200" step="5" value="60">
                    <span class="unit">px</span>
                </div>
                <div class="config-item">
                    <label>Padding:<span class="info-icon" data-tooltip="Space between the shapes and the box edges">‚Ñπ</span></label>
                    <input type="number" id="triangle_padding" min="0" max="100" step="5" value="45">
                    <span class="unit">px</span>
                </div>
                
                <h4 style="color: #777; font-size: 15px; margin-top: 15px; margin-bottom: 10px;">‚ñ¨ Rectangle</h4>
                <div class="config-item">
                    <label>Gap horizontal:<span class="info-icon" data-tooltip="Horizontal spacing between shapes in the same row (left-right)">‚Ñπ</span></label>
                    <input type="number" id="rectangle_gapH" min="0" max="200" step="5" value="60">
                    <span class="unit">px</span>
                </div>
                <div class="config-item">
                    <label>Gap vertical:<span class="info-icon" data-tooltip="Vertical spacing between shapes in different rows (top-bottom)">‚Ñπ</span></label>
                    <input type="number" id="rectangle_gapV" min="0" max="200" step="5" value="60">
                    <span class="unit">px</span>
                </div>
                <div class="config-item">
                    <label>Padding:<span class="info-icon" data-tooltip="Space between the shapes and the box edges">‚Ñπ</span></label>
                    <input type="number" id="rectangle_padding" min="0" max="100" step="5" value="45">
                    <span class="unit">px</span>
                </div>
                
                <h4 style="color: #777; font-size: 15px; margin-top: 15px; margin-bottom: 10px;">‚òÖ Star</h4>
                <div class="config-item">
                    <label>Gap horizontal:<span class="info-icon" data-tooltip="Horizontal spacing between shapes in the same row (left-right)">‚Ñπ</span></label>
                    <input type="number" id="star_gapH" min="0" max="200" step="5" value="60">
                    <span class="unit">px</span>
                </div>
                <div class="config-item">
                    <label>Gap vertical:<span class="info-icon" data-tooltip="Vertical spacing between shapes in different rows (top-bottom)">‚Ñπ</span></label>
                    <input type="number" id="star_gapV" min="0" max="200" step="5" value="60">
                    <span class="unit">px</span>
                </div>
                <div class="config-item">
                    <label>Padding:<span class="info-icon" data-tooltip="Space between the shapes and the box edges">‚Ñπ</span></label>
                    <input type="number" id="star_padding" min="0" max="100" step="5" value="45">
                    <span class="unit">px</span>
                </div>
            </div>

            <div class="config-section">
                <h3>Fruit Spacing (by fruit type)</h3>
                
                <h4 style="color: #777; font-size: 15px; margin-top: 15px; margin-bottom: 10px;">üçé Apple</h4>
                <div class="config-item">
                    <label>Gap horizontal:<span class="info-icon" data-tooltip="Horizontal spacing between fruits next to each other (column gap)">‚Ñπ</span></label>
                    <input type="number" id="apple_gapH" min="0" max="200" step="5" value="77">
                    <span class="unit">px</span>
                </div>
                <div class="config-item">
                    <label>Gap vertical:<span class="info-icon" data-tooltip="Vertical spacing between fruits in different rows (row gap)">‚Ñπ</span></label>
                    <input type="number" id="apple_gapV" min="0" max="200" step="5" value="77">
                    <span class="unit">px</span>
                </div>
                <div class="config-item">
                    <label>Group offset:<span class="info-icon" data-tooltip="Moves the entire fruit group to different positions (top/bottom/left/right)">‚Ñπ</span></label>
                    <input type="number" id="apple_offset" min="0" max="200" step="5" value="84">
                    <span class="unit">px</span>
                </div>
                
                <h4 style="color: #777; font-size: 15px; margin-top: 15px; margin-bottom: 10px;">üçê Pear</h4>
                <div class="config-item">
                    <label>Gap horizontal:<span class="info-icon" data-tooltip="Horizontal spacing between fruits next to each other (column gap)">‚Ñπ</span></label>
                    <input type="number" id="pear_gapH" min="0" max="200" step="5" value="77">
                    <span class="unit">px</span>
                </div>
                <div class="config-item">
                    <label>Gap vertical:<span class="info-icon" data-tooltip="Vertical spacing between fruits in different rows (row gap)">‚Ñπ</span></label>
                    <input type="number" id="pear_gapV" min="0" max="200" step="5" value="77">
                    <span class="unit">px</span>
                </div>
                <div class="config-item">
                    <label>Group offset:<span class="info-icon" data-tooltip="Moves the entire fruit group to different positions (top/bottom/left/right)">‚Ñπ</span></label>
                    <input type="number" id="pear_offset" min="0" max="200" step="5" value="84">
                    <span class="unit">px</span>
                </div>
                
                <h4 style="color: #777; font-size: 15px; margin-top: 15px; margin-bottom: 10px;">üçä Orange</h4>
                <div class="config-item">
                    <label>Gap horizontal:<span class="info-icon" data-tooltip="Horizontal spacing between fruits next to each other (column gap)">‚Ñπ</span></label>
                    <input type="number" id="orange_gapH" min="0" max="200" step="5" value="77">
                    <span class="unit">px</span>
                </div>
                <div class="config-item">
                    <label>Gap vertical:<span class="info-icon" data-tooltip="Vertical spacing between fruits in different rows (row gap)">‚Ñπ</span></label>
                    <input type="number" id="orange_gapV" min="0" max="200" step="5" value="77">
                    <span class="unit">px</span>
                </div>
                <div class="config-item">
                    <label>Group offset:<span class="info-icon" data-tooltip="Moves the entire fruit group to different positions (top/bottom/left/right)">‚Ñπ</span></label>
                    <input type="number" id="orange_offset" min="0" max="200" step="5" value="84">
                    <span class="unit">px</span>
                </div>
                
                <h4 style="color: #777; font-size: 15px; margin-top: 15px; margin-bottom: 10px;">üçå Banana</h4>
                <div class="config-item">
                    <label>Gap horizontal:<span class="info-icon" data-tooltip="Horizontal spacing between fruits next to each other (column gap)">‚Ñπ</span></label>
                    <input type="number" id="banana_gapH" min="0" max="200" step="5" value="77">
                    <span class="unit">px</span>
                </div>
                <div class="config-item">
                    <label>Gap vertical:<span class="info-icon" data-tooltip="Vertical spacing between fruits in different rows (row gap)">‚Ñπ</span></label>
                    <input type="number" id="banana_gapV" min="0" max="200" step="5" value="77">
                    <span class="unit">px</span>
                </div>
                <div class="config-item">
                    <label>Group offset:<span class="info-icon" data-tooltip="Moves the entire fruit group to different positions (top/bottom/left/right)">‚Ñπ</span></label>
                    <input type="number" id="banana_offset" min="0" max="200" step="5" value="84">
                    <span class="unit">px</span>
                </div>
                
                <h4 style="color: #777; font-size: 15px; margin-top: 15px; margin-bottom: 10px;">üçí Cherry</h4>
                <div class="config-item">
                    <label>Gap horizontal:<span class="info-icon" data-tooltip="Horizontal spacing between fruits next to each other (column gap)">‚Ñπ</span></label>
                    <input type="number" id="cherry_gapH" min="0" max="200" step="5" value="77">
                    <span class="unit">px</span>
                </div>
                <div class="config-item">
                    <label>Gap vertical:<span class="info-icon" data-tooltip="Vertical spacing between fruits in different rows (row gap)">‚Ñπ</span></label>
                    <input type="number" id="cherry_gapV" min="0" max="200" step="5" value="77">
                    <span class="unit">px</span>
                </div>
                <div class="config-item">
                    <label>Group offset:<span class="info-icon" data-tooltip="Moves the entire fruit group to different positions (top/bottom/left/right)">‚Ñπ</span></label>
                    <input type="number" id="cherry_offset" min="0" max="200" step="5" value="84">
                    <span class="unit">px</span>
                </div>
            </div>

            <div class="modal-actions">
                <button id="resetConfigBtn" class="btn-danger">Reset to Default</button>
                <button id="exportConfigBtn" class="btn-secondary">Export Config</button>
                <button id="importConfigBtn" class="btn-secondary">Import Config</button>
                <button id="saveConfigBtn">Save & Apply</button>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('testCanvas');
        const ctx = canvas.getContext('2d');
        let currentTestType = 'number-vs-features';

        // Default spacing configuration - now per shape/fruit type
        const DEFAULT_CONFIG = {
            shapes: {
                circle: { gapH: 60, gapV: 60, padding: 45 },
                square: { gapH: 60, gapV: 60, padding: 45 },
                triangle: { gapH: 60, gapV: 60, padding: 45 },
                rectangle: { gapH: 60, gapV: 60, padding: 45 },
                star: { gapH: 60, gapV: 60, padding: 45 }
            },
            fruits: {
                apple: { gapH: 77, gapV: 77, offset: 84 },
                pear: { gapH: 77, gapV: 77, offset: 84 },
                orange: { gapH: 77, gapV: 77, offset: 84 },
                banana: { gapH: 77, gapV: 77, offset: 84 },
                cherry: { gapH: 77, gapV: 77, offset: 84 }
            }
        };

        // Current spacing configuration
        let spacingConfig = JSON.parse(JSON.stringify(DEFAULT_CONFIG));

        // Load configuration from localStorage
        function loadConfig() {
            const saved = localStorage.getItem('spacingConfig');
            if (saved) {
                try {
                    const parsed = JSON.parse(saved);
                    spacingConfig = JSON.parse(JSON.stringify(DEFAULT_CONFIG));
                    // Deep merge for shapes
                    if (parsed.shapes) {
                        Object.keys(parsed.shapes).forEach(shape => {
                            if (spacingConfig.shapes[shape]) {
                                Object.assign(spacingConfig.shapes[shape], parsed.shapes[shape]);
                            }
                        });
                    }
                    // Deep merge for fruits
                    if (parsed.fruits) {
                        Object.keys(parsed.fruits).forEach(fruit => {
                            if (spacingConfig.fruits[fruit]) {
                                Object.assign(spacingConfig.fruits[fruit], parsed.fruits[fruit]);
                            }
                        });
                    }
                } catch (e) {
                    console.error('Failed to load config:', e);
                    spacingConfig = JSON.parse(JSON.stringify(DEFAULT_CONFIG));
                }
            }
            updateConfigInputs();
        }

        // Save configuration to localStorage
        function saveConfig() {
            localStorage.setItem('spacingConfig', JSON.stringify(spacingConfig));
        }

        // Update config input values
        function updateConfigInputs() {
            // Update shape configs
            ['circle', 'square', 'triangle', 'rectangle', 'star'].forEach(shape => {
                const config = spacingConfig.shapes[shape];
                document.getElementById(`${shape}_gapH`).value = config.gapH;
                document.getElementById(`${shape}_gapV`).value = config.gapV;
                document.getElementById(`${shape}_padding`).value = config.padding;
            });
            
            // Update fruit configs
            ['apple', 'pear', 'orange', 'banana', 'cherry'].forEach(fruit => {
                const config = spacingConfig.fruits[fruit];
                document.getElementById(`${fruit}_gapH`).value = config.gapH;
                document.getElementById(`${fruit}_gapV`).value = config.gapV;
                document.getElementById(`${fruit}_offset`).value = config.offset;
            });
        }

        // Read config from inputs
        function readConfigFromInputs() {
            spacingConfig = {
                shapes: {},
                fruits: {}
            };
            
            // Read shape configs
            ['circle', 'square', 'triangle', 'rectangle', 'star'].forEach(shape => {
                spacingConfig.shapes[shape] = {
                    gapH: parseFloat(document.getElementById(`${shape}_gapH`).value),
                    gapV: parseFloat(document.getElementById(`${shape}_gapV`).value),
                    padding: parseFloat(document.getElementById(`${shape}_padding`).value)
                };
            });
            
            // Read fruit configs
            ['apple', 'pear', 'orange', 'banana', 'cherry'].forEach(fruit => {
                spacingConfig.fruits[fruit] = {
                    gapH: parseFloat(document.getElementById(`${fruit}_gapH`).value),
                    gapV: parseFloat(document.getElementById(`${fruit}_gapV`).value),
                    offset: parseFloat(document.getElementById(`${fruit}_offset`).value)
                };
            });
        }

        // Reset configuration to defaults
        function resetConfig() {
            spacingConfig = JSON.parse(JSON.stringify(DEFAULT_CONFIG));
            updateConfigInputs();
            saveConfig();
            generateTest();
        }

        // Export configuration as JSON
        function exportConfig() {
            const dataStr = JSON.stringify(spacingConfig, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `spacing-config-${Date.now()}.json`;
            link.click();
            URL.revokeObjectURL(url);
        }

        // Import configuration from JSON
        function importConfig() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'application/json';
            input.onchange = (e) => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        try {
                            const imported = JSON.parse(event.target.result);
                            spacingConfig = { ...DEFAULT_CONFIG, ...imported };
                            updateConfigInputs();
                            saveConfig();
                            generateTest();
                            alert('Configuration imported successfully!');
                        } catch (error) {
                            alert('Failed to import configuration: ' + error.message);
                        }
                    };
                    reader.readAsText(file);
                }
            };
            input.click();
        }

        // Modal control
        const modal = document.getElementById('configModal');
        const configBtn = document.getElementById('configBtn');
        const closeBtn = document.querySelector('.close');
        const saveConfigBtn = document.getElementById('saveConfigBtn');
        const resetConfigBtn = document.getElementById('resetConfigBtn');
        const exportConfigBtn = document.getElementById('exportConfigBtn');
        const importConfigBtn = document.getElementById('importConfigBtn');

        configBtn.onclick = () => {
            modal.classList.add('show');
        };

        closeBtn.onclick = () => {
            modal.classList.remove('show');
        };

        window.onclick = (event) => {
            if (event.target === modal) {
                modal.classList.remove('show');
            }
        };

        saveConfigBtn.onclick = () => {
            readConfigFromInputs();
            saveConfig();
            generateTest();
            modal.classList.remove('show');
        };

        resetConfigBtn.onclick = () => {
            if (confirm('Are you sure you want to reset to default spacing values?')) {
                resetConfig();
            }
        };

        exportConfigBtn.onclick = exportConfig;
        importConfigBtn.onclick = importConfig;

        // Test type selection
        document.querySelectorAll('.test-type-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.test-type-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentTestType = btn.dataset.type;
            });
        });

        // Fruit drawing functions
        function drawFruit(x, y, size, fruit, pattern, position = 'center') {
            ctx.save();
            
            // Position adjustment based on location (for B2-style requirements)
            let offsetX = 0, offsetY = 0;
            if (position === 'top') offsetY = -size * 0.6;
            else if (position === 'bottom') offsetY = size * 0.6;
            else if (position === 'left') offsetX = -size * 0.6;
            else if (position === 'right') offsetX = size * 0.6;
            
            ctx.translate(x + offsetX, y + offsetY);
            
            // Draw fruit based on type
            switch(fruit) {
                case 'apple':
                    drawApple(0, 0, size, pattern);
                    break;
                case 'pear':
                    drawPear(0, 0, size, pattern);
                    break;
                case 'orange':
                    drawOrange(0, 0, size, pattern);
                    break;
                case 'banana':
                    drawBanana(0, 0, size, pattern);
                    break;
                case 'cherry':
                    drawCherry(0, 0, size, pattern);
                    break;
            }
            
            ctx.restore();
        }

        function drawApple(x, y, size, pattern) {
            const baseColor = '#DC143C'; // Red
            
            ctx.save();
            ctx.translate(x, y);
            
            // Apple body
            ctx.beginPath();
            ctx.ellipse(0, size * 0.1, size * 0.4, size * 0.45, 0, 0, Math.PI * 2);
            ctx.fillStyle = baseColor;
            ctx.fill();
            
            // Leaves and stem
            ctx.fillStyle = '#228B22';
            ctx.beginPath();
            ctx.ellipse(size * 0.15, -size * 0.3, size * 0.15, size * 0.08, Math.PI / 4, 0, Math.PI * 2);
            ctx.fill();
            
            // Apply pattern with proper clipping
            if (pattern !== 'solid') {
                ctx.save();
                ctx.beginPath();
                ctx.ellipse(0, size * 0.1, size * 0.4, size * 0.45, 0, 0, Math.PI * 2);
                ctx.clip();
                applyPattern(pattern, size * 0.9);
                ctx.restore();
            }
            
            ctx.strokeStyle = '#8B0000';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.ellipse(0, size * 0.1, size * 0.4, size * 0.45, 0, 0, Math.PI * 2);
            ctx.stroke();
            
            // Stem
            ctx.fillStyle = '#654321';
            ctx.fillRect(-size * 0.05, -size * 0.4, size * 0.1, size * 0.4);
            
            // Leaf
            ctx.fillStyle = '#228B22';
            ctx.beginPath();
            ctx.ellipse(size * 0.15, -size * 0.3, size * 0.15, size * 0.08, Math.PI / 4, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.restore();
        }

        function drawPear(x, y, size, pattern) {
            const baseColor = '#9ACD32';
            const outlineColor = '#6B8E23';
            const creaseColor = '#D9F47D';
            const scale = 0.7;
            const s = size * scale;
            
            ctx.save();
            ctx.translate(x, y);

            const tracePearBody = () => {
                ctx.beginPath();
                ctx.moveTo(0, s * 0.55);
                ctx.bezierCurveTo(-s * 0.48, s * 0.55, -s * 0.65, s * 0.12, -s * 0.32, -s * 0.38);
                ctx.bezierCurveTo(-s * 0.18, -s * 0.64, -s * 0.05, -s * 0.74, 0, -s * 0.68);
                ctx.bezierCurveTo(s * 0.05, -s * 0.74, s * 0.18, -s * 0.64, s * 0.32, -s * 0.38);
                ctx.bezierCurveTo(s * 0.65, s * 0.12, s * 0.48, s * 0.55, 0, s * 0.55);
                ctx.closePath();
            };

            tracePearBody();
            ctx.fillStyle = baseColor;
            ctx.fill();

            if (pattern !== 'solid') {
                ctx.save();
                tracePearBody();
                ctx.clip();
                applyPattern(pattern, s);
                ctx.restore();
            }

            ctx.strokeStyle = outlineColor;
            ctx.lineWidth = 2;
            tracePearBody();
            ctx.stroke();

            // Leaf and stem
            ctx.fillStyle = '#3A9D41';
            ctx.beginPath();
            ctx.ellipse(s * 0.32, -s * 0.36, s * 0.22, s * 0.11, Math.PI / 10, 0, Math.PI * 2);
            ctx.fill();

            ctx.strokeStyle = '#654321';
            ctx.lineWidth = s * 0.12;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(-s * 0.02, -s * 0.58);
            ctx.lineTo(s * 0.06, -s * 0.7);
            ctx.stroke();
            
            ctx.restore();
        }

        function drawOrange(x, y, size, pattern) {
            const baseColor = '#FFA500'; // Orange
            
            ctx.save();
            ctx.translate(x, y);
            
            // Orange body
            ctx.beginPath();
            ctx.arc(0, 0, size * 0.45, 0, Math.PI * 2);
            ctx.fillStyle = baseColor;
            ctx.fill();
            
            // Apply pattern with proper clipping
            if (pattern !== 'solid') {
                ctx.save();
                ctx.beginPath();
                ctx.arc(0, 0, size * 0.45, 0, Math.PI * 2);
                ctx.clip();
                applyPattern(pattern, size * 0.9);
                ctx.restore();
            }
            
            ctx.strokeStyle = '#FF8C00';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(0, 0, size * 0.45, 0, Math.PI * 2);
            ctx.stroke();
            
            // Texture dots - only show for solid pattern to maintain fruit identity
            if (pattern === 'solid') {
                ctx.fillStyle = '#CC7000';
                // Fixed seed positions for consistency
                const dotPositions = [
                    [0.2, 0.1], [-0.15, 0.15], [0.1, -0.2], [-0.2, -0.1],
                    [0.25, -0.05], [-0.1, -0.25], [0, 0.25], [-0.25, 0.05]
                ];
                dotPositions.forEach(([dx, dy]) => {
                    ctx.beginPath();
                    ctx.arc(dx * size, dy * size, size * 0.02, 0, Math.PI * 2);
                    ctx.fill();
                });
            }
            
            ctx.restore();
        }

        function drawBanana(x, y, size, pattern) {
            const baseColor = '#FFD966'; // Banana yellow
            
            ctx.save();
            ctx.translate(x, y);
            
            // Banana curved shape - more curvy and longer
            ctx.beginPath();
            ctx.moveTo(-size * 0.5, -size * 0.1);
            ctx.bezierCurveTo(-size * 0.4, -size * 0.35, -size * 0.1, -size * 0.4, 0.1 * size, -size * 0.35);
            ctx.bezierCurveTo(size * 0.3, -size * 0.3, size * 0.45, -size * 0.15, size * 0.5, 0.05);
            ctx.bezierCurveTo(size * 0.48, 0.2, size * 0.4, 0.3, size * 0.25, 0.35);
            ctx.bezierCurveTo(size * 0.1, 0.35, -size * 0.1, 0.3, -size * 0.3, 0.2);
            ctx.bezierCurveTo(-size * 0.42, 0.15, -size * 0.48, 0.05, -size * 0.5, -0.1);
            ctx.closePath();
            ctx.fillStyle = baseColor;
            ctx.fill();
            
            // Apply pattern with proper clipping
            if (pattern !== 'solid') {
                ctx.save();
                ctx.beginPath();
                ctx.moveTo(-size * 0.5, -size * 0.1);
                ctx.bezierCurveTo(-size * 0.4, -size * 0.35, -size * 0.1, -size * 0.4, 0.1 * size, -size * 0.35);
                ctx.bezierCurveTo(size * 0.3, -size * 0.3, size * 0.45, -size * 0.15, size * 0.5, 0.05);
                ctx.bezierCurveTo(size * 0.48, 0.2, size * 0.4, 0.3, size * 0.25, 0.35);
                ctx.bezierCurveTo(size * 0.1, 0.35, -size * 0.1, 0.3, -size * 0.3, 0.2);
                ctx.bezierCurveTo(-size * 0.42, 0.15, -size * 0.48, 0.05, -size * 0.5, -0.1);
                ctx.closePath();
                ctx.clip();
                applyPattern(pattern, size);
                ctx.restore();
            }
            
            ctx.strokeStyle = '#DAA520';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(-size * 0.5, -size * 0.1);
            ctx.bezierCurveTo(-size * 0.4, -size * 0.35, -size * 0.1, -size * 0.4, 0.1 * size, -size * 0.35);
            ctx.bezierCurveTo(size * 0.3, -size * 0.3, size * 0.45, -size * 0.15, size * 0.5, 0.05);
            ctx.bezierCurveTo(size * 0.48, 0.2, size * 0.4, 0.3, size * 0.25, 0.35);
            ctx.bezierCurveTo(size * 0.1, 0.35, -size * 0.1, 0.3, -size * 0.3, 0.2);
            ctx.bezierCurveTo(-size * 0.42, 0.15, -size * 0.48, 0.05, -size * 0.5, -0.1);
            ctx.closePath();
            ctx.stroke();
            
            // Stem end
            ctx.fillStyle = '#654321';
            ctx.fillRect(-size * 0.52, -size * 0.15, size * 0.08, size * 0.12);
            
            ctx.restore();
        }

        function drawCherry(x, y, size, pattern) {
    const fruitColor = '#D63031';
    const outlineColor = '#A81F22';
    const highlightColor = 'rgba(255,255,255,0.5)';
    const stemColor = '#6B4A2B';
    const leafColor = '#2ECC71';

    ctx.save();
    ctx.translate(x, y);

    const scale = 0.7;
    const radius = size * 0.32 * scale;
    const offsetX = radius * 1.0;
    const offsetY = size * 0.05 * scale;
    const cherries = [
        { cx: -offsetX, cy: offsetY },
        { cx: offsetX, cy: offsetY }
    ];

    cherries.forEach(({ cx, cy }) => {
        ctx.save();
        ctx.translate(cx, cy);

        ctx.beginPath();
        ctx.arc(0, 0, radius, 0, Math.PI * 2);
        ctx.fillStyle = fruitColor;
        ctx.fill();

        if (pattern !== 'solid') {
            ctx.save();
            ctx.beginPath();
            ctx.arc(0, 0, radius, 0, Math.PI * 2);
            ctx.clip();
            applyPattern(pattern, radius * 2.1);
            ctx.restore();
        }

        ctx.strokeStyle = outlineColor;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(0, 0, radius, 0, Math.PI * 2);
        ctx.stroke();

        // Highlight
        ctx.fillStyle = highlightColor;
        ctx.beginPath();
        ctx.ellipse(-radius * 0.25, -radius * 0.35, radius * 0.18, radius * 0.1, -Math.PI / 6, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();
    });

    // Stems
    ctx.strokeStyle = stemColor;
    ctx.lineCap = 'round';
    ctx.lineWidth = size * 0.08 * scale;
    ctx.beginPath();
    ctx.moveTo(-offsetX * 0.9, offsetY - radius * 0.9);
    ctx.bezierCurveTo(-offsetX * 0.4, -size * 0.2, -size * 0.1, -size * 0.25, 0, -size * 0.3);
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(offsetX * 0.9, offsetY - radius * 0.9);
    ctx.bezierCurveTo(offsetX * 0.4, -size * 0.2, size * 0.1, -size * 0.25, 0, -size * 0.3);
    ctx.stroke();

    // Leaf at top junction
    ctx.fillStyle = leafColor;
    ctx.save();
    ctx.translate(size * 0.14, -size * 0.38);
    ctx.rotate(Math.PI / 7);
    ctx.beginPath();
    ctx.ellipse(0, 0, size * 0.14, size * 0.07, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();

    // Stem tip
    ctx.strokeStyle = stemColor;
    ctx.lineWidth = size * 0.08 * scale;
    ctx.beginPath();
    ctx.moveTo(0, -size * 0.3);
    ctx.lineTo(size * 0.01, -size * 0.45);
    ctx.stroke();

    ctx.restore();
}

        function applyPattern(pattern, size) {
            if (pattern === 'solid') return;
            
            // Pattern uses white background for better contrast
            // This creates white vs fruit color (e.g., white vs red for strawberry)
            switch(pattern) {
                case 'striped':
                    // Thicker, less dense stripes with white color
                    ctx.fillStyle = 'white';
                    for(let i = -size; i < size; i += 20) {
                        ctx.fillRect(i, -size, 10, size * 2);
                    }
                    break;
                case 'dotted':
                    // Bigger, more visible dots with white color
                    ctx.fillStyle = 'white';
                    for(let dx = -size/2; dx < size/2; dx += 18) {
                        for(let dy = -size/2; dy < size/2; dy += 18) {
                            ctx.beginPath();
                            ctx.arc(dx, dy, 4, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }
                    break;
                case 'grid':
                    // Checkerboard pattern with white
                    ctx.fillStyle = 'white';
                    const squareSize = 12;
                    for(let x = -size; x < size; x += squareSize) {
                        for(let y = -size; y < size; y += squareSize) {
                            // Checkerboard logic
                            const col = Math.floor((x + size) / squareSize);
                            const row = Math.floor((y + size) / squareSize);
                            if ((col + row) % 2 === 0) {
                                ctx.fillRect(x, y, squareSize, squareSize);
                            }
                        }
                    }
                    break;
            }
        }

        // Shape drawing functions
        function drawShape(x, y, size, shape, color, pattern, rotation = 0) {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(rotation);

            // Create path for the shape
            ctx.beginPath();
            switch(shape) {
                case 'circle':
                    ctx.arc(0, 0, size/2, 0, Math.PI * 2);
                    break;
                case 'square':
                    ctx.rect(-size/2, -size/2, size, size);
                    break;
                case 'triangle':
                    ctx.moveTo(0, -size/2);
                    ctx.lineTo(size/2, size/2);
                    ctx.lineTo(-size/2, size/2);
                    ctx.closePath();
                    break;
                case 'rectangle':
                    ctx.rect(-size/2, -size/3, size, size * 2/3);
                    break;
                case 'hexagon':
                    for(let i = 0; i < 6; i++) {
                        const angle = (Math.PI / 3) * i;
                        const px = (size/2) * Math.cos(angle);
                        const py = (size/2) * Math.sin(angle);
                        if(i === 0) ctx.moveTo(px, py);
                        else ctx.lineTo(px, py);
                    }
                    ctx.closePath();
                    break;
                case 'star':
                    for(let i = 0; i < 5; i++) {
                        const angle = (Math.PI * 2 / 5) * i - Math.PI/2;
                        const outerX = (size/2) * Math.cos(angle);
                        const outerY = (size/2) * Math.sin(angle);
                        const innerAngle = angle + Math.PI/5;
                        const innerX = (size/4) * Math.cos(innerAngle);
                        const innerY = (size/4) * Math.sin(innerAngle);
                        if(i === 0) ctx.moveTo(outerX, outerY);
                        else ctx.lineTo(outerX, outerY);
                        ctx.lineTo(innerX, innerY);
                    }
                    ctx.closePath();
                    break;
                case 'crescent':
                    ctx.arc(size/6, 0, size/2, 0, Math.PI * 2);
                    ctx.arc(0, 0, size/2, 0, Math.PI * 2, true);
                    break;
            }

            // Fill with base color
            ctx.fillStyle = color;
            ctx.fill();
            
            // Apply pattern if not solid
            if(pattern !== 'solid') {
                ctx.save();
                ctx.clip();
                applyPattern(pattern, size);
                ctx.restore();
            }

            // Draw outline
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.stroke();

            ctx.restore();
        }

        function arrangeShapes(count, boxX, boxY, boxSize, size, shapeType) {
            const positions = [];
            
            // Get shape-specific configuration
            const shapeConfig = spacingConfig.shapes[shapeType] || spacingConfig.shapes.circle;
            
            // Calculate safe margins - shapes must fit completely within the box
            const shapeRadius = size / 2;
            const safePadding = shapeRadius + shapeConfig.padding;
            const usableWidth = boxSize - (safePadding * 2);
            const usableHeight = boxSize - (safePadding * 2);

            // Determine grid layout based on count for nice arrangements
            let cols, rows;
            if (count === 2) {
                cols = 2;
                rows = 1;
            } else if (count === 3) {
                // Triangle arrangement: 1 on top, 2 on bottom
                cols = 2;
                rows = 2;
            } else if (count === 4) {
                cols = 2;
                rows = 2;
            } else if (count === 5) {
                // Pentagon-like: 2 on top, 3 on bottom
                cols = 3;
                rows = 2;
            } else if (count === 6) {
                cols = 3;
                rows = 2;
            } else {
                cols = Math.ceil(Math.sqrt(count));
                rows = Math.ceil(count / cols);
            }
            
            // Base position starts at padding boundary
            const baseX = boxX + safePadding;
            const baseY = boxY + safePadding;
            
            // Special arrangements for odd numbers
            if (count === 3) {
                // 1 centered on top, 2 on bottom
                // Top row: 1 shape centered
                const topRowWidth = size;
                const topCenterX = baseX + (usableWidth - topRowWidth) / 2;
                positions.push({
                    x: topCenterX + size / 2,
                    y: baseY + size / 2,
                    rotation: 0
                });
                // Bottom row: 2 shapes
                const bottomRowWidth = size * 2 + shapeConfig.gapH;
                const bottomCenterX = baseX + (usableWidth - bottomRowWidth) / 2;
                positions.push({
                    x: bottomCenterX + size / 2,
                    y: baseY + size + shapeConfig.gapV + size / 2,
                    rotation: 0
                });
                positions.push({
                    x: bottomCenterX + size + shapeConfig.gapH + size / 2,
                    y: baseY + size + shapeConfig.gapV + size / 2,
                    rotation: 0
                });
            } else if (count === 5) {
                // 2 on top, 3 on bottom
                // Top row: 2 shapes
                const topRowWidth = size * 2 + shapeConfig.gapH;
                const topCenterX = baseX + (usableWidth - topRowWidth) / 2;
                positions.push({
                    x: topCenterX + size / 2,
                    y: baseY + size / 2,
                    rotation: 0
                });
                positions.push({
                    x: topCenterX + size + shapeConfig.gapH + size / 2,
                    y: baseY + size / 2,
                    rotation: 0
                });
                // Bottom row: 3 shapes
                const bottomRowWidth = size * 3 + shapeConfig.gapH * 2;
                const bottomCenterX = baseX + (usableWidth - bottomRowWidth) / 2;
                for(let i = 0; i < 3; i++) {
                    positions.push({
                        x: bottomCenterX + (size + shapeConfig.gapH) * i + size / 2,
                        y: baseY + size + shapeConfig.gapV + size / 2,
                        rotation: 0
                    });
                }
            } else {
                // Standard grid for even numbers (2, 4, 6)
                // Center the grid horizontally only, start from top padding
                const gridWidth = size * cols + shapeConfig.gapH * (cols - 1);
                const startX = baseX + (usableWidth - gridWidth) / 2;
                const startY = baseY;
                
                for(let i = 0; i < count; i++) {
                    const col = i % cols;
                    const row = Math.floor(i / cols);
                    
                    const x = startX + (size + shapeConfig.gapH) * col + size / 2;
                    const y = startY + (size + shapeConfig.gapV) * row + size / 2;
                    
                    positions.push({
                        x: x,
                        y: y,
                        rotation: 0
                    });
                }
            }
            
            return positions;
        }
        
        function randomArrangement() {
            // Not used anymore, but kept for compatibility
            return 'grid';
        }

        function drawBox(x, y, size, label) {
            // Fill white background first
            ctx.fillStyle = 'white';
            ctx.fillRect(x, y, size, size);
            
            // Draw border
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 6;
            ctx.strokeRect(x, y, size, size);
            
            // Draw label
            ctx.fillStyle = '#666';
            ctx.font = 'bold 32px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(label, x + size/2, y - 20);
        }

        function randomChoice(arr) {
            return arr[Math.floor(Math.random() * arr.length)];
        }

        function randomColor() {
            const colors = ['#FF6B35', '#4ECDC4', '#FFD93D', '#A855F7', '#3B82F6', '#EF4444'];
            return randomChoice(colors);
        }

        function randomShape() {
            const shapes = ['circle', 'square', 'triangle', 'rectangle', 'star'];
            return randomChoice(shapes);
        }

        function randomPattern() {
            const patterns = ['solid', 'striped', 'dotted', 'grid'];
            return randomChoice(patterns);
        }

        function randomFruit() {
            const fruits = ['apple', 'pear', 'orange', 'banana', 'cherry'];
            return randomChoice(fruits);
        }

        function generateTest() {
            // Always use horizontal layout
            canvas.width = 2400;
            canvas.height = 800;
            
            // Clear canvas with white background
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Scale everything up for better resolution
            const boxSize = 380;
            const margin = 60;
            const shapeSize = 70;

            // Get target parameters
            const targetType = document.getElementById('targetType').value;
            const targetCount = parseInt(document.getElementById('targetCount').value);
            const targetPattern = document.getElementById('targetPattern').value;
            
            const boxY = 200;

            if (targetType === 'shape') {
                // Original shape-based logic
                const targetShape = document.getElementById('targetShape').value;
                const targetColor = document.getElementById('targetColor').value;

                // Generate choices
                const choices = [];
                const correctIndex = Math.floor(Math.random() * 4);
                const usedCounts = new Set([targetCount]);
                const usedColors = new Set([targetColor]);

                for(let i = 0; i < 4; i++) {
                    let choice;
                    if(i === correctIndex) {
                        // Correct answer - same count, different shape and color
                        let choiceColor;
                        let colorAttempts = 0;
                        do {
                            choiceColor = randomColor();
                            colorAttempts++;
                        } while(usedColors.has(choiceColor) && colorAttempts < 20);
                        
                        usedColors.add(choiceColor);
                        
                        choice = {
                            count: targetCount,
                            shape: randomShape(),
                            color: choiceColor,
                            pattern: targetPattern
                        };
                    } else {
                        // Foil answers - different count (must be unique)
                        let count;
                        let attempts = 0;
                        do {
                            count = Math.floor(Math.random() * 5) + 2;
                            attempts++;
                            if (attempts > 20) {
                                for (let c = 2; c <= 6; c++) {
                                    if (!usedCounts.has(c)) {
                                        count = c;
                                        break;
                                    }
                                }
                                break;
                            }
                        } while(usedCounts.has(count));
                        
                        usedCounts.add(count);
                        
                        let choiceColor;
                        let colorAttempts = 0;
                        do {
                            choiceColor = randomColor();
                            colorAttempts++;
                        } while(usedColors.has(choiceColor) && colorAttempts < 20);
                        
                        usedColors.add(choiceColor);
                        
                        choice = {
                            count: count,
                            shape: randomShape(),
                            color: choiceColor,
                            pattern: targetPattern
                        };
                    }
                    choices.push(choice);
                }

                // Draw target
                const targetX = margin;
                drawBox(targetX, boxY, boxSize, 'ÁõÆÊ†á');
                const targetPositions = arrangeShapes(targetCount, targetX, boxY, boxSize, shapeSize, targetShape);
                targetPositions.forEach(pos => {
                    drawShape(pos.x, pos.y, shapeSize, targetShape, targetColor, targetPattern, pos.rotation);
                });

                // Draw choices
                for(let i = 0; i < 4; i++) {
                    const x = margin + (boxSize + margin) * (i + 1);
                    drawBox(x, boxY, boxSize, `${i + 1}`);
                    const positions = arrangeShapes(choices[i].count, x, boxY, boxSize, shapeSize, choices[i].shape);
                    positions.forEach(pos => {
                        drawShape(pos.x, pos.y, shapeSize, choices[i].shape, choices[i].color, choices[i].pattern, pos.rotation);
                    });
                }

                console.log(`Correct answer: ${correctIndex + 1}`);
                
            } else if (targetType === 'fruit') {
                // Fruit-based logic with B2 positioning requirements
                const targetFruit = document.getElementById('targetFruit').value;
                const usedFruits = new Set([targetFruit]);

                // Generate choices according to requirements:
                // 1. Different fruit types for each choice
                // 2. Pattern handling based on mode
                // 3. One option with same count as target (correct answer)
                // 4. Each choice's fruit group positioned at different locations (top, bottom, left, right)
                
                const choices = [];
                const correctIndex = Math.floor(Math.random() * 4); // Correct answer has same count
                const usedCounts = new Set([targetCount]);
                const positions = ['top', 'bottom', 'left', 'right'];
                const targetGroupPosition = randomChoice(['top', 'bottom', 'left', 'right', 'center']);
                // Shuffle positions array
                for (let i = positions.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [positions[i], positions[j]] = [positions[j], positions[i]];
                }

                // Handle fullrandom pattern - ensure all 4 patterns appear
                let targetPatternValue = targetPattern;
                let choicePatterns = [];
                
                if (targetPattern === 'fullrandom') {
                    const allPatterns = ['solid', 'striped', 'dotted', 'grid'];
                    // Shuffle patterns to randomize assignment
                    const shuffledPatterns = [...allPatterns].sort(() => Math.random() - 0.5);
                    // Target uses the first pattern
                    targetPatternValue = shuffledPatterns[0];
                    // Remaining unique patterns for other choices
                    const remainingPatterns = shuffledPatterns.slice(1);
                    const otherPatterns = remainingPatterns.sort(() => Math.random() - 0.5);
                    // Ensure exactly one choice matches the target pattern
                    const samePatternChoiceIndex = Math.floor(Math.random() * 4);
                    choicePatterns = new Array(4);
                    choicePatterns[samePatternChoiceIndex] = targetPatternValue;
                    let otherIndex = 0;
                    for (let i = 0; i < 4; i++) {
                        if (i === samePatternChoiceIndex) continue;
                        choicePatterns[i] = otherPatterns[otherIndex % otherPatterns.length];
                        otherIndex++;
                    }
                }

                for(let i = 0; i < 4; i++) {
                    // Get unique fruit type
                    let fruit;
                    let attempts = 0;
                    do {
                        fruit = randomFruit();
                        attempts++;
                    } while(usedFruits.has(fruit) && attempts < 20);
                    usedFruits.add(fruit);

                    let choice;
                    const choicePattern = targetPattern === 'fullrandom' ? choicePatterns[i] : targetPattern;
                    
                    if(i === correctIndex) {
                        // Correct answer - same count as target
                        choice = {
                            count: targetCount,
                            fruit: fruit,
                            pattern: choicePattern,
                            position: positions[i]
                        };
                    } else {
                        // Other options - different count
                        let count;
                        let countAttempts = 0;
                        do {
                            count = Math.floor(Math.random() * 5) + 2;
                            countAttempts++;
                        } while(usedCounts.has(count) && countAttempts < 20);
                        usedCounts.add(count);
                        
                        choice = {
                            count: count,
                            fruit: fruit,
                            pattern: choicePattern,
                            position: positions[i]
                        };
                    }
                    choices.push(choice);
                }

                // Arrange fruits in a compact group, then shift entire group based on position
                const getPositionsForCount = (count, centerX, centerY, boxSize, groupPosition, fruitType) => {
                    const positions = [];
                    // Get fruit-specific configuration
                    const fruitConfig = spacingConfig.fruits[fruitType] || spacingConfig.fruits.apple;
                    const spacingH = fruitConfig.gapH; // Horizontal gap between fruits
                    const spacingV = fruitConfig.gapV; // Vertical gap between fruits
                    
                    // First, arrange fruits in a compact group around origin (0,0)
                    let relativePositions = [];
                    switch (count) {
                        case 1:
                            relativePositions.push({ x: 0, y: 0 });
                            break;
                        case 2:
                            relativePositions.push({ x: -spacingH * 0.6, y: 0 });
                            relativePositions.push({ x: spacingH * 0.6, y: 0 });
                            break;
                        case 3:
                            relativePositions.push({ x: 0, y: -spacingV * 0.6 });
                            relativePositions.push({ x: -spacingH * 0.6, y: spacingV * 0.6 });
                            relativePositions.push({ x: spacingH * 0.6, y: spacingV * 0.6 });
                            break;
                        case 4:
                            relativePositions.push({ x: -spacingH * 0.6, y: -spacingV * 0.6 });
                            relativePositions.push({ x: spacingH * 0.6, y: -spacingV * 0.6 });
                            relativePositions.push({ x: -spacingH * 0.6, y: spacingV * 0.6 });
                            relativePositions.push({ x: spacingH * 0.6, y: spacingV * 0.6 });
                            break;
                        case 5: {
                            const twoTop = Math.random() < 0.5;
                            const rowOffset = spacingV * 0.9;
                            const colOffset = spacingH * 1.0;
                            if (twoTop) {
                                // Top row: 2
                                relativePositions.push({ x: -colOffset * 0.5, y: -rowOffset });
                                relativePositions.push({ x: colOffset * 0.5, y: -rowOffset });
                                // Bottom row: 3
                                relativePositions.push({ x: -colOffset, y: rowOffset });
                                relativePositions.push({ x: 0, y: rowOffset });
                                relativePositions.push({ x: colOffset, y: rowOffset });
                            } else {
                                // Top row: 3
                                relativePositions.push({ x: -colOffset, y: -rowOffset });
                                relativePositions.push({ x: 0, y: -rowOffset });
                                relativePositions.push({ x: colOffset, y: -rowOffset });
                                // Bottom row: 2
                                relativePositions.push({ x: -colOffset * 0.5, y: rowOffset });
                                relativePositions.push({ x: colOffset * 0.5, y: rowOffset });
                            }
                            break;
                        }
                        case 6: {
                            const useVertical = groupPosition === 'left' || groupPosition === 'right';
                            if (useVertical) {
                                // 2 columns x 3 rows (taller layout)
                                const colOffset = spacingH * 1.05;
                                const rowOffset = spacingV * 0.95;
                                const columns = [-colOffset * 0.5, colOffset * 0.5];
                                const rows = [-rowOffset, 0, rowOffset];
                                columns.forEach(x => {
                                    rows.forEach(y => {
                                        relativePositions.push({ x, y });
                                    });
                                });
                            } else {
                                // 3 columns x 2 rows (wider layout)
                                const colOffset = spacingH * 1.0;
                                const rowOffset = spacingV * 0.9;
                                const columns = [-colOffset, 0, colOffset];
                                const rows = [-rowOffset, rowOffset];
                                columns.forEach(x => {
                                    rows.forEach(y => {
                                        relativePositions.push({ x, y });
                                    });
                                });
                            }
                            break;
                        }
                        default:
                            // Fallback: distribute in simple grid
                            const cols = Math.ceil(Math.sqrt(count));
                            const rows = Math.ceil(count / cols);
                            for (let i = 0; i < count; i++) {
                                const col = i % cols;
                                const row = Math.floor(i / cols);
                                const offsetX = (col - (cols - 1) / 2) * spacingH;
                                const offsetY = (row - (rows - 1) / 2) * spacingV;
                                relativePositions.push({ x: offsetX, y: offsetY });
                            }
                    }
                    
                    // Now shift the ENTIRE group based on groupPosition
                    const offset = fruitConfig.offset; // Configurable group offset
                    let groupOffsetX = 0, groupOffsetY = 0;
                    
                    switch(groupPosition) {
                        case 'top':
                            groupOffsetY = -offset;
                            break;
                        case 'bottom':
                            groupOffsetY = offset;
                            break;
                        case 'left':
                            groupOffsetX = -offset;
                            break;
                        case 'right':
                            groupOffsetX = offset;
                            break;
                        case 'center':
                        default:
                            // No offset
                            break;
                    }
                    
                    // Apply group offset to all fruits
                    relativePositions.forEach(pos => {
                        positions.push({
                            x: centerX + pos.x + groupOffsetX,
                            y: centerY + pos.y + groupOffsetY
                        });
                    });
                    
                    return positions;
                };

                // Draw target
                const targetX = margin;
                drawBox(targetX, boxY, boxSize, 'ÁõÆÊ†á');
                const targetCenterX = targetX + boxSize / 2;
                const targetCenterY = boxY + boxSize / 2;
                const targetPositions = getPositionsForCount(targetCount, targetCenterX, targetCenterY, boxSize, targetGroupPosition, targetFruit);
                targetPositions.forEach(pos => {
                    drawFruit(pos.x, pos.y, shapeSize, targetFruit, targetPatternValue, 'center');
                });

                // Draw choices with positioned fruits
                for(let i = 0; i < 4; i++) {
                    const x = margin + (boxSize + margin) * (i + 1);
                    drawBox(x, boxY, boxSize, `${i + 1}`);
                    const centerX = x + boxSize / 2;
                    const centerY = boxY + boxSize / 2;
                    
                    const fruitPositions = getPositionsForCount(choices[i].count, centerX, centerY, boxSize, choices[i].position, choices[i].fruit);
                    fruitPositions.forEach(pos => {
                        drawFruit(pos.x, pos.y, shapeSize, choices[i].fruit, choices[i].pattern, 'center');
                    });
                }

                console.log(`Correct answer: ${correctIndex + 1}`);
                if (targetPattern === 'fullrandom') {
                    console.log(`Full Random Mode - Target: ${targetPatternValue}`);
                    console.log('Choice patterns:', choices.map((c, i) => `${i+1}: ${c.pattern}`).join(', '));
                } else {
                    console.log(`All fruits use pattern: ${targetPattern}`);
                }
            }
        }

        function downloadTest() {
            const link = document.createElement('a');
            link.download = `attention-to-number-test-${Date.now()}.png`;
            link.href = canvas.toDataURL();
            link.click();
        }

        // Preview update functions
        function updateShapePreview() {
            const previewCanvas = document.getElementById('shapePreview');
            const previewCtx = previewCanvas.getContext('2d');
            const shape = document.getElementById('targetShape').value;
            const color = document.getElementById('targetColor').value;
            
            previewCtx.clearRect(0, 0, 35, 35);
            drawShape(17.5, 17.5, 28, shape, color, 'solid', 0);
        }

        function updateColorPreview() {
            const previewCanvas = document.getElementById('colorPreview');
            const previewCtx = previewCanvas.getContext('2d');
            const color = document.getElementById('targetColor').value;
            
            previewCtx.clearRect(0, 0, 35, 35);
            previewCtx.fillStyle = color;
            previewCtx.fillRect(2, 2, 31, 31);
            previewCtx.strokeStyle = '#333';
            previewCtx.lineWidth = 2;
            previewCtx.strokeRect(2, 2, 31, 31);
        }

        function updatePatternPreview() {
            const previewCanvas = document.getElementById('patternPreview');
            const previewCtx = previewCanvas.getContext('2d');
            const pattern = document.getElementById('targetPattern').value;
            const color = document.getElementById('targetColor').value;
            
            previewCtx.clearRect(0, 0, 35, 35);
            
            if (pattern === 'fullrandom') {
                // Show mixed pattern preview
                previewCtx.fillStyle = '#888';
                previewCtx.font = '20px Arial';
                previewCtx.textAlign = 'center';
                previewCtx.textBaseline = 'middle';
                previewCtx.fillText('üé≤', 17.5, 17.5);
            } else {
                drawShape(17.5, 17.5, 28, 'square', color, pattern, 0);
            }
        }

        function updateFruitPreview() {
            const previewCanvas = document.getElementById('fruitPreview');
            const previewCtx = previewCanvas.getContext('2d');
            const fruit = document.getElementById('targetFruit').value;
            let pattern = document.getElementById('targetPattern').value;
            
            previewCtx.clearRect(0, 0, 35, 35);
            
            // For fullrandom, show solid as preview
            if (pattern === 'fullrandom') {
                pattern = 'solid';
            }
            
            // Draw fruit directly with previewCtx
            const savedCtx = ctx;
            window.ctx = previewCtx; // Temporarily set global ctx
            drawFruit(17.5, 17.5, 24, fruit, pattern, 'center');
            window.ctx = savedCtx; // Restore
        }

        function toggleTargetType() {
            const targetType = document.getElementById('targetType').value;
            const shapeGroup = document.getElementById('shapeGroup');
            const fruitGroup = document.getElementById('fruitGroup');
            const colorGroup = document.getElementById('colorGroup');
            const fullrandomOption = document.getElementById('fullrandomOption');
            const targetPattern = document.getElementById('targetPattern');
            
            if (targetType === 'shape') {
                shapeGroup.classList.remove('hidden');
                fruitGroup.classList.add('hidden');
                colorGroup.classList.remove('hidden');
                fullrandomOption.classList.add('hidden');
                // Reset to solid if it was fullrandom
                if (targetPattern.value === 'fullrandom') {
                    targetPattern.value = 'solid';
                    updatePatternPreview();
                }
            } else {
                shapeGroup.classList.add('hidden');
                fruitGroup.classList.remove('hidden');
                colorGroup.classList.add('hidden'); // Hide color for fruits
                fullrandomOption.classList.remove('hidden');
                // Set default to fullrandom for fruits
                targetPattern.value = 'fullrandom';
                updatePatternPreview();
                updateFruitPreview();
            }
        }

        // Add event listeners for preview updates
        document.getElementById('targetType').addEventListener('change', () => {
            toggleTargetType();
            generateTest();
        });
        
        document.getElementById('targetShape').addEventListener('change', () => {
            updateShapePreview();
            updatePatternPreview();
        });
        document.getElementById('targetColor').addEventListener('change', () => {
            updateShapePreview();
            updateColorPreview();
            updatePatternPreview();
        });
        document.getElementById('targetPattern').addEventListener('change', () => {
            updatePatternPreview();
            if (document.getElementById('targetType').value === 'fruit') {
                updateFruitPreview();
            }
        });
        
        document.getElementById('targetFruit').addEventListener('change', updateFruitPreview);

        document.getElementById('generateBtn').addEventListener('click', generateTest);
        document.getElementById('downloadBtn').addEventListener('click', downloadTest);

        // Load configuration and generate initial test
        loadConfig();
        toggleTargetType();
        updateShapePreview();
        updateColorPreview();
        updatePatternPreview();
        updateFruitPreview();
        generateTest();
    </script>
</body>
</html>
