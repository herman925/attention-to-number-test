<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Attention to Number Test Generator</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: Arial, sans-serif;
            padding: 20px;
            background-color: #f5f5f5;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 30px;
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
            padding: 20px;
            background: #f9f9f9;
            border-radius: 8px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        label {
            font-weight: bold;
            color: #555;
            font-size: 14px;
        }

        select, input[type="number"], input[type="color"] {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }

        /* Custom select styling with previews */
        .select-with-preview {
            position: relative;
        }

        .select-wrapper {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .select-preview {
            width: 35px;
            height: 35px;
            border: 2px solid #333;
            border-radius: 4px;
            flex-shrink: 0;
            background: white;
        }

        .select-wrapper select {
            flex: 1;
        }

        button {
            padding: 12px 24px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: background-color 0.3s;
        }

        button:hover {
            background-color: #45a049;
        }

        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }

        .action-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-bottom: 30px;
        }

        #downloadBtn {
            background-color: #2196F3;
        }

        #downloadBtn:hover {
            background-color: #0b7dda;
        }

        #testCanvas {
            border: 2px solid #ddd;
            display: block;
            margin: 0 auto;
            background: white;
            border-radius: 8px;
            max-width: 100%;
            height: auto;
        }

        .info {
            text-align: center;
            color: #666;
            margin-top: 20px;
            font-size: 14px;
        }

        .test-type-selector {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            justify-content: center;
        }

        .test-type-btn {
            padding: 10px 20px;
            background-color: #e0e0e0;
            color: #333;
            border: 2px solid transparent;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
        }

        .test-type-btn.active {
            background-color: #4CAF50;
            color: white;
            border-color: #45a049;
        }

        .hidden {
            display: none;
        }

        /* Modal Styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.4);
        }

        .modal.show {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-content {
            background-color: #fefefe;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            max-width: 600px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            border-bottom: 2px solid #ddd;
            padding-bottom: 15px;
        }

        .modal-header h2 {
            margin: 0;
            color: #333;
        }

        .close {
            color: #aaa;
            font-size: 32px;
            font-weight: bold;
            cursor: pointer;
            line-height: 1;
        }

        .close:hover,
        .close:focus {
            color: #000;
        }

        .config-section {
            margin-bottom: 25px;
        }

        .config-section h3 {
            color: #555;
            margin-bottom: 15px;
            font-size: 18px;
            border-bottom: 1px solid #eee;
            padding-bottom: 8px;
        }

        .config-item {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
            gap: 15px;
        }

        .config-item label {
            flex: 1;
            font-weight: normal;
            color: #666;
            font-size: 14px;
        }

        .config-item input[type="number"] {
            width: 100px;
            padding: 6px 10px;
        }

        .config-item .unit {
            color: #999;
            font-size: 13px;
            width: 40px;
        }

        .modal-actions {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
            margin-top: 25px;
            padding-top: 20px;
            border-top: 2px solid #ddd;
        }

        .modal-actions button {
            padding: 10px 20px;
            font-size: 14px;
        }

        .btn-secondary {
            background-color: #6c757d;
        }

        .btn-secondary:hover {
            background-color: #5a6268;
        }

        .btn-danger {
            background-color: #dc3545;
        }

        .btn-danger:hover {
            background-color: #c82333;
        }

        .config-button {
            background-color: #6c757d;
            margin-right: 10px;
        }

        .config-button:hover {
            background-color: #5a6268;
        }

        .info-icon {
            display: inline-block;
            width: 18px;
            height: 18px;
            background-color: #4ECDC4;
            color: white;
            border-radius: 50%;
            text-align: center;
            line-height: 18px;
            font-size: 12px;
            font-weight: bold;
            cursor: help;
            margin-left: 5px;
            position: relative;
        }

        .info-icon:hover::after {
            content: attr(data-tooltip);
            position: absolute;
            left: 25px;
            top: 50%;
            transform: translateY(-50%);
            background-color: #333;
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            white-space: nowrap;
            z-index: 1000;
            font-size: 13px;
            font-weight: normal;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }

        .info-icon:hover::before {
            content: '';
            position: absolute;
            left: 20px;
            top: 50%;
            transform: translateY(-50%);
            border: 5px solid transparent;
            border-right-color: #333;
            z-index: 1001;
        }

        /* Tab Styles */
        .tabs {
            display: flex;
            gap: 5px;
            margin-bottom: 20px;
            border-bottom: 2px solid #ddd;
        }

        .tab-button {
            padding: 10px 20px;
            background-color: #f0f0f0;
            border: none;
            border-top: 2px solid transparent;
            border-left: 2px solid transparent;
            border-right: 2px solid transparent;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            color: #666;
            transition: all 0.3s;
            border-radius: 5px 5px 0 0;
        }

        .tab-button:hover {
            background-color: #e8e8e8;
            color: #333;
        }

        .tab-button.active {
            background-color: white;
            color: #333;
            border-top-color: #4CAF50;
            border-left-color: #ddd;
            border-right-color: #ddd;
            border-bottom: 2px solid white;
            margin-bottom: -2px;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Attention to Number Test Generator</h1>
        


        <div class="controls">
            <div class="control-group">
                <label for="targetType">Target Type:</label>
                <select id="targetType">
                    <option value="shape">Shape</option>
                    <option value="fruit">Fruit</option>
                </select>
            </div>

            <div class="control-group">
                <label for="targetCount">Target Count:</label>
                <select id="targetCount">
                    <option value="2">2</option>
                    <option value="3">3</option>
                    <option value="4" selected>4</option>
                    <option value="5">5</option>
                    <option value="6">6</option>
                </select>
            </div>

            <div class="control-group select-with-preview" id="shapeGroup">
                <label for="targetShape">Target Shape:</label>
                <div class="select-wrapper">
                    <canvas id="shapePreview" width="35" height="35" class="select-preview"></canvas>
                    <select id="targetShape">
                        <option value="circle">‚ö´ Circle</option>
                        <option value="square">‚¨õ Square</option>
                        <option value="triangle">‚ñ≤ Triangle</option>
                        <option value="rectangle">‚ñ¨ Rectangle</option>
                        <option value="star">‚òÖ Star</option>
                    </select>
                </div>
            </div>

            <div class="control-group select-with-preview hidden" id="fruitGroup">
                <label for="targetFruit">Target Fruit:</label>
                <div class="select-wrapper">
                    <canvas id="fruitPreview" width="35" height="35" class="select-preview"></canvas>
                    <select id="targetFruit">
                        <option value="apple">üçé Apple</option>
                        <option value="pear">üçê Pear</option>
                        <option value="orange">üçä Orange</option>
                        <option value="banana">üçå Banana</option>
                        <option value="cherry">üçí Cherry</option>
                    </select>
                </div>
            </div>

            <div class="control-group select-with-preview" id="colorGroup">
                <label for="targetColor">Target Color:</label>
                <div class="select-wrapper">
                    <canvas id="colorPreview" width="35" height="35" class="select-preview"></canvas>
                    <select id="targetColor">
                        <option value="#FF6B35">üü† Orange</option>
                        <option value="#4ECDC4">üî∑ Teal</option>
                        <option value="#FFD93D">üü° Yellow</option>
                        <option value="#A855F7">üü£ Purple</option>
                        <option value="#3B82F6">üîµ Blue</option>
                        <option value="#EF4444">üî¥ Red</option>
                    </select>
                </div>
            </div>

            <div class="control-group select-with-preview">
                <label for="targetPattern">Target Pattern:</label>
                <div class="select-wrapper">
                    <canvas id="patternPreview" width="35" height="35" class="select-preview"></canvas>
                    <select id="targetPattern">
                        <option value="solid" id="solidPatternOption">‚ñ† Solid Fill</option>
                        <option value="horizontal-stripes">‚âã Horizontal Stripes</option>
                        <option value="vertical-stripes">‚ïë Vertical Stripes</option>
                        <option value="checkered">‚ñ¶ Checkered</option>
                        <option value="white-dots">‚óå White Dots</option>
                        <option value="fullrandom" id="fullrandomOption" class="hidden">üé≤ Full Random</option>
                    </select>
                </div>
            </div>

        </div>

        <div class="action-buttons">
            <button id="generateBtn">Generate Test</button>
            <button id="downloadBtn">Download as PNG</button>
            <button id="configBtn" class="config-button">‚öôÔ∏è Spacing Configuration</button>
        </div>

        <canvas id="testCanvas" width="1600" height="900"></canvas>

        <div class="info">
            <p>The test includes a target and 4 choices. Only one choice will match based on the selected test type.</p>
        </div>
    </div>

    <!-- Spacing Configuration Modal -->
    <div id="configModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Spacing Configuration</h2>
                <span class="close">&times;</span>
            </div>
            
            <!-- Tabs -->
            <div class="tabs">
                <button class="tab-button active" data-tab="shapes">Shape Spacing</button>
                <button class="tab-button" data-tab="fruits">Fruit Spacing</button>
                <button class="tab-button" data-tab="layouts">Layout Multipliers</button>
            </div>
            
            <!-- Tab Content: Shape Spacing -->
            <div id="shapes-tab" class="tab-content active">
                <div class="config-section">
                    <h3>Shape Spacing (by shape type)</h3>
                
                <h4 style="color: #777; font-size: 15px; margin-top: 15px; margin-bottom: 10px;">‚ö´ Circle</h4>
                <div class="config-item">
                    <label>Gap horizontal:<span class="info-icon" data-tooltip="Horizontal spacing between shapes in the same row (left-right)">‚Ñπ</span></label>
                    <input type="number" id="circle_gapH" min="0" max="200" step="5" value="60">
                    <span class="unit">px</span>
                </div>
                <div class="config-item">
                    <label>Gap vertical:<span class="info-icon" data-tooltip="Vertical spacing between shapes in different rows (top-bottom)">‚Ñπ</span></label>
                    <input type="number" id="circle_gapV" min="0" max="200" step="5" value="60">
                    <span class="unit">px</span>
                </div>
                <div class="config-item">
                    <label>Padding:<span class="info-icon" data-tooltip="Space between the shapes and the box edges">‚Ñπ</span></label>
                    <input type="number" id="circle_padding" min="0" max="100" step="5" value="45">
                    <span class="unit">px</span>
                </div>
                
                <h4 style="color: #777; font-size: 15px; margin-top: 15px; margin-bottom: 10px;">‚¨õ Square</h4>
                <div class="config-item">
                    <label>Gap horizontal:<span class="info-icon" data-tooltip="Horizontal spacing between shapes in the same row (left-right)">‚Ñπ</span></label>
                    <input type="number" id="square_gapH" min="0" max="200" step="5" value="60">
                    <span class="unit">px</span>
                </div>
                <div class="config-item">
                    <label>Gap vertical:<span class="info-icon" data-tooltip="Vertical spacing between shapes in different rows (top-bottom)">‚Ñπ</span></label>
                    <input type="number" id="square_gapV" min="0" max="200" step="5" value="60">
                    <span class="unit">px</span>
                </div>
                <div class="config-item">
                    <label>Padding:<span class="info-icon" data-tooltip="Space between the shapes and the box edges">‚Ñπ</span></label>
                    <input type="number" id="square_padding" min="0" max="100" step="5" value="45">
                    <span class="unit">px</span>
                </div>
                
                <h4 style="color: #777; font-size: 15px; margin-top: 15px; margin-bottom: 10px;">‚ñ≤ Triangle</h4>
                <div class="config-item">
                    <label>Gap horizontal:<span class="info-icon" data-tooltip="Horizontal spacing between shapes in the same row (left-right)">‚Ñπ</span></label>
                    <input type="number" id="triangle_gapH" min="0" max="200" step="5" value="60">
                    <span class="unit">px</span>
                </div>
                <div class="config-item">
                    <label>Gap vertical:<span class="info-icon" data-tooltip="Vertical spacing between shapes in different rows (top-bottom)">‚Ñπ</span></label>
                    <input type="number" id="triangle_gapV" min="0" max="200" step="5" value="60">
                    <span class="unit">px</span>
                </div>
                <div class="config-item">
                    <label>Padding:<span class="info-icon" data-tooltip="Space between the shapes and the box edges">‚Ñπ</span></label>
                    <input type="number" id="triangle_padding" min="0" max="100" step="5" value="45">
                    <span class="unit">px</span>
                </div>
                
                <h4 style="color: #777; font-size: 15px; margin-top: 15px; margin-bottom: 10px;">‚ñ¨ Rectangle</h4>
                <div class="config-item">
                    <label>Gap horizontal:<span class="info-icon" data-tooltip="Horizontal spacing between shapes in the same row (left-right)">‚Ñπ</span></label>
                    <input type="number" id="rectangle_gapH" min="0" max="200" step="5" value="60">
                    <span class="unit">px</span>
                </div>
                <div class="config-item">
                    <label>Gap vertical:<span class="info-icon" data-tooltip="Vertical spacing between shapes in different rows (top-bottom)">‚Ñπ</span></label>
                    <input type="number" id="rectangle_gapV" min="0" max="200" step="5" value="60">
                    <span class="unit">px</span>
                </div>
                <div class="config-item">
                    <label>Padding:<span class="info-icon" data-tooltip="Space between the shapes and the box edges">‚Ñπ</span></label>
                    <input type="number" id="rectangle_padding" min="0" max="100" step="5" value="45">
                    <span class="unit">px</span>
                </div>
                
                <h4 style="color: #777; font-size: 15px; margin-top: 15px; margin-bottom: 10px;">‚òÖ Star</h4>
                <div class="config-item">
                    <label>Gap horizontal:<span class="info-icon" data-tooltip="Horizontal spacing between shapes in the same row (left-right)">‚Ñπ</span></label>
                    <input type="number" id="star_gapH" min="0" max="200" step="5" value="60">
                    <span class="unit">px</span>
                </div>
                <div class="config-item">
                    <label>Gap vertical:<span class="info-icon" data-tooltip="Vertical spacing between shapes in different rows (top-bottom)">‚Ñπ</span></label>
                    <input type="number" id="star_gapV" min="0" max="200" step="5" value="60">
                    <span class="unit">px</span>
                </div>
                <div class="config-item">
                    <label>Padding:<span class="info-icon" data-tooltip="Space between the shapes and the box edges">‚Ñπ</span></label>
                    <input type="number" id="star_padding" min="0" max="100" step="5" value="45">
                    <span class="unit">px</span>
                </div>
                </div>
            </div>

            <!-- Tab Content: Fruit Spacing -->
            <div id="fruits-tab" class="tab-content">
                <div class="config-section">
                    <h3>Fruit Spacing (by fruit type)</h3>
                
                <h4 style="color: #777; font-size: 15px; margin-top: 15px; margin-bottom: 10px;">üçé Apple</h4>
                <div class="config-item">
                    <label>Gap horizontal:<span class="info-icon" data-tooltip="Horizontal spacing between fruits next to each other (column gap)">‚Ñπ</span></label>
                    <input type="number" id="apple_gapH" min="0" max="200" step="5" value="77">
                    <span class="unit">px</span>
                </div>
                <div class="config-item">
                    <label>Gap vertical:<span class="info-icon" data-tooltip="Vertical spacing between fruits in different rows (row gap)">‚Ñπ</span></label>
                    <input type="number" id="apple_gapV" min="0" max="200" step="5" value="77">
                    <span class="unit">px</span>
                </div>
                <div class="config-item">
                    <label>Group offset X:<span class="info-icon" data-tooltip="Moves the fruit group left/right when positioned on the sides">‚Ñπ</span></label>
                    <input type="number" id="apple_offsetX" min="0" max="200" step="5" value="84">
                    <span class="unit">px</span>
                </div>
                <div class="config-item">
                    <label>Group offset Y:<span class="info-icon" data-tooltip="Moves the fruit group up/down when positioned top or bottom">‚Ñπ</span></label>
                    <input type="number" id="apple_offsetY" min="0" max="200" step="5" value="84">
                    <span class="unit">px</span>
                </div>
                
                <h4 style="color: #777; font-size: 15px; margin-top: 15px; margin-bottom: 10px;">üçê Pear</h4>
                <div class="config-item">
                    <label>Gap horizontal:<span class="info-icon" data-tooltip="Horizontal spacing between fruits next to each other (column gap)">‚Ñπ</span></label>
                    <input type="number" id="pear_gapH" min="0" max="200" step="5" value="77">
                    <span class="unit">px</span>
                </div>
                <div class="config-item">
                    <label>Gap vertical:<span class="info-icon" data-tooltip="Vertical spacing between fruits in different rows (row gap)">‚Ñπ</span></label>
                    <input type="number" id="pear_gapV" min="0" max="200" step="5" value="77">
                    <span class="unit">px</span>
                </div>
                <div class="config-item">
                    <label>Group offset X:<span class="info-icon" data-tooltip="Moves the fruit group left/right when positioned on the sides">‚Ñπ</span></label>
                    <input type="number" id="pear_offsetX" min="0" max="200" step="5" value="84">
                    <span class="unit">px</span>
                </div>
                <div class="config-item">
                    <label>Group offset Y:<span class="info-icon" data-tooltip="Moves the fruit group up/down when positioned top or bottom">‚Ñπ</span></label>
                    <input type="number" id="pear_offsetY" min="0" max="200" step="5" value="84">
                    <span class="unit">px</span>
                </div>
                
                <h4 style="color: #777; font-size: 15px; margin-top: 15px; margin-bottom: 10px;">üçä Orange</h4>
                <div class="config-item">
                    <label>Gap horizontal:<span class="info-icon" data-tooltip="Horizontal spacing between fruits next to each other (column gap)">‚Ñπ</span></label>
                    <input type="number" id="orange_gapH" min="0" max="200" step="5" value="77">
                    <span class="unit">px</span>
                </div>
                <div class="config-item">
                    <label>Gap vertical:<span class="info-icon" data-tooltip="Vertical spacing between fruits in different rows (row gap)">‚Ñπ</span></label>
                    <input type="number" id="orange_gapV" min="0" max="200" step="5" value="77">
                    <span class="unit">px</span>
                </div>
                <div class="config-item">
                    <label>Group offset X:<span class="info-icon" data-tooltip="Moves the fruit group left/right when positioned on the sides">‚Ñπ</span></label>
                    <input type="number" id="orange_offsetX" min="0" max="200" step="5" value="84">
                    <span class="unit">px</span>
                </div>
                <div class="config-item">
                    <label>Group offset Y:<span class="info-icon" data-tooltip="Moves the fruit group up/down when positioned top or bottom">‚Ñπ</span></label>
                    <input type="number" id="orange_offsetY" min="0" max="200" step="5" value="84">
                    <span class="unit">px</span>
                </div>
                
                <h4 style="color: #777; font-size: 15px; margin-top: 15px; margin-bottom: 10px;">üçå Banana</h4>
                <div class="config-item">
                    <label>Gap horizontal:<span class="info-icon" data-tooltip="Horizontal spacing between fruits next to each other (column gap)">‚Ñπ</span></label>
                    <input type="number" id="banana_gapH" min="0" max="200" step="5" value="77">
                    <span class="unit">px</span>
                </div>
                <div class="config-item">
                    <label>Gap vertical:<span class="info-icon" data-tooltip="Vertical spacing between fruits in different rows (row gap)">‚Ñπ</span></label>
                    <input type="number" id="banana_gapV" min="0" max="200" step="5" value="77">
                    <span class="unit">px</span>
                </div>
                <div class="config-item">
                    <label>Group offset X:<span class="info-icon" data-tooltip="Moves the fruit group left/right when positioned on the sides">‚Ñπ</span></label>
                    <input type="number" id="banana_offsetX" min="0" max="200" step="5" value="84">
                    <span class="unit">px</span>
                </div>
                <div class="config-item">
                    <label>Group offset Y:<span class="info-icon" data-tooltip="Moves the fruit group up/down when positioned top or bottom">‚Ñπ</span></label>
                    <input type="number" id="banana_offsetY" min="0" max="200" step="5" value="84">
                    <span class="unit">px</span>
                </div>
                
                <h4 style="color: #777; font-size: 15px; margin-top: 15px; margin-bottom: 10px;">üçí Cherry</h4>
                <div class="config-item">
                    <label>Gap horizontal:<span class="info-icon" data-tooltip="Horizontal spacing between fruits next to each other (column gap)">‚Ñπ</span></label>
                    <input type="number" id="cherry_gapH" min="0" max="200" step="5" value="77">
                    <span class="unit">px</span>
                </div>
                <div class="config-item">
                    <label>Gap vertical:<span class="info-icon" data-tooltip="Vertical spacing between fruits in different rows (row gap)">‚Ñπ</span></label>
                    <input type="number" id="cherry_gapV" min="0" max="200" step="5" value="77">
                    <span class="unit">px</span>
                </div>
                <div class="config-item">
                    <label>Group offset X:<span class="info-icon" data-tooltip="Moves the fruit group left/right when positioned on the sides">‚Ñπ</span></label>
                    <input type="number" id="cherry_offsetX" min="0" max="200" step="5" value="84">
                    <span class="unit">px</span>
                </div>
                <div class="config-item">
                    <label>Group offset Y:<span class="info-icon" data-tooltip="Moves the fruit group up/down when positioned top or bottom">‚Ñπ</span></label>
                    <input type="number" id="cherry_offsetY" min="0" max="200" step="5" value="84">
                    <span class="unit">px</span>
                </div>
                </div>
            </div>

            <!-- Tab Content: Layout Multipliers -->
            <div id="layouts-tab" class="tab-content">
                <div class="config-section">
                    <h3>Layout-Specific Gap Multipliers</h3>
                    <p style="color: #666; font-size: 13px; margin-bottom: 15px;">Multipliers adjust gaps based on grid arrangement (e.g., 3√ó2 vs 2√ó3 for 6 items). Values > 1.0 increase gaps, < 1.0 decrease them.</p>
                
                <h4 style="color: #777; font-size: 15px; margin-top: 15px; margin-bottom: 10px;">2 Items Layouts</h4>
                <div class="config-item">
                    <label>1√ó2 (horizontal):<span class="info-icon" data-tooltip="Multiplier for 1 row, 2 columns arrangement">‚Ñπ</span></label>
                    <input type="number" id="layout_1x2_gapH" min="0" max="3" step="0.1" value="1.0">
                    <span class="unit" style="width: 50px;">H gap</span>
                    <input type="number" id="layout_1x2_gapV" min="0" max="3" step="0.1" value="1.0">
                    <span class="unit" style="width: 50px;">V gap</span>
                </div>
                <div class="config-item">
                    <label>2√ó1 (vertical):<span class="info-icon" data-tooltip="Multiplier for 2 rows, 1 column arrangement">‚Ñπ</span></label>
                    <input type="number" id="layout_2x1_gapH" min="0" max="3" step="0.1" value="1.0">
                    <span class="unit" style="width: 50px;">H gap</span>
                    <input type="number" id="layout_2x1_gapV" min="0" max="3" step="0.1" value="1.0">
                    <span class="unit" style="width: 50px;">V gap</span>
                </div>
                
                <h4 style="color: #777; font-size: 15px; margin-top: 15px; margin-bottom: 10px;">3 Items Layouts</h4>
                <div class="config-item">
                    <label>1√ó3 (horizontal):<span class="info-icon" data-tooltip="Multiplier for 1 row, 3 columns arrangement">‚Ñπ</span></label>
                    <input type="number" id="layout_1x3_gapH" min="0" max="3" step="0.1" value="1.0">
                    <span class="unit" style="width: 50px;">H gap</span>
                    <input type="number" id="layout_1x3_gapV" min="0" max="3" step="0.1" value="1.0">
                    <span class="unit" style="width: 50px;">V gap</span>
                </div>
                <div class="config-item">
                    <label>3√ó1 (vertical):<span class="info-icon" data-tooltip="Multiplier for 3 rows, 1 column arrangement">‚Ñπ</span></label>
                    <input type="number" id="layout_3x1_gapH" min="0" max="3" step="0.1" value="1.0">
                    <span class="unit" style="width: 50px;">H gap</span>
                    <input type="number" id="layout_3x1_gapV" min="0" max="3" step="0.1" value="1.0">
                    <span class="unit" style="width: 50px;">V gap</span>
                </div>
                
                <h4 style="color: #777; font-size: 15px; margin-top: 15px; margin-bottom: 10px;">4 Items Layouts</h4>
                <div class="config-item">
                    <label>2√ó2 (square):<span class="info-icon" data-tooltip="Multiplier for 2 rows, 2 columns arrangement">‚Ñπ</span></label>
                    <input type="number" id="layout_2x2_gapH" min="0" max="3" step="0.1" value="1.0">
                    <span class="unit" style="width: 50px;">H gap</span>
                    <input type="number" id="layout_2x2_gapV" min="0" max="3" step="0.1" value="1.0">
                    <span class="unit" style="width: 50px;">V gap</span>
                </div>
                
                <h4 style="color: #777; font-size: 15px; margin-top: 15px; margin-bottom: 10px;">5 Items Layouts</h4>
                <div class="config-item">
                    <label>3√ó2 rows (2-3 or 3-2):<span class="info-icon" data-tooltip="For top/bottom positions: 2 rows, 3 columns (2 on top + 3 on bottom, or vice versa)">‚Ñπ</span></label>
                    <input type="number" id="layout_3x2_5items_gapH" min="0" max="3" step="0.1" value="1.0">
                    <span class="unit" style="width: 50px;">H gap</span>
                    <input type="number" id="layout_3x2_5items_gapV" min="0" max="3" step="0.1" value="1.0">
                    <span class="unit" style="width: 50px;">V gap</span>
                </div>
                <div class="config-item">
                    <label>2√ó3 cols (2|3 or 3|2):<span class="info-icon" data-tooltip="For left/right positions: 2 columns (one with 2 fruits, one with 3 fruits, vertically centered)">‚Ñπ</span></label>
                    <input type="number" id="layout_2x3_5items_gapH" min="0" max="3" step="0.1" value="1.0">
                    <span class="unit" style="width: 50px;">H gap</span>
                    <input type="number" id="layout_2x3_5items_gapV" min="0" max="3" step="0.1" value="1.0">
                    <span class="unit" style="width: 50px;">V gap</span>
                </div>
                
                <h4 style="color: #777; font-size: 15px; margin-top: 15px; margin-bottom: 10px;">6 Items Layouts</h4>
                <div class="config-item">
                    <label>3√ó2 (wider):<span class="info-icon" data-tooltip="Multiplier for 2 rows, 3 columns arrangement (horizontal)">‚Ñπ</span></label>
                    <input type="number" id="layout_3x2_gapH" min="0" max="3" step="0.1" value="1.0">
                    <span class="unit" style="width: 50px;">H gap</span>
                    <input type="number" id="layout_3x2_gapV" min="0" max="3" step="0.1" value="1.0">
                    <span class="unit" style="width: 50px;">V gap</span>
                </div>
                <div class="config-item">
                    <label>2√ó3 (taller):<span class="info-icon" data-tooltip="Multiplier for 3 rows, 2 columns arrangement (vertical)">‚Ñπ</span></label>
                    <input type="number" id="layout_2x3_gapH" min="0" max="3" step="0.1" value="1.0">
                    <span class="unit" style="width: 50px;">H gap</span>
                    <input type="number" id="layout_2x3_gapV" min="0" max="3" step="0.1" value="1.0">
                    <span class="unit" style="width: 50px;">V gap</span>
                </div>
                </div>
            </div>

            <div class="modal-actions">
                <button id="resetConfigBtn" class="btn-danger">Reset to Default</button>
                <button id="exportConfigBtn" class="btn-secondary">Export Config</button>
                <button id="importConfigBtn" class="btn-secondary">Import Config</button>
                <button id="saveConfigBtn">Save & Apply</button>
            </div>
        </div>
    </div>

    <script>
    const canvas = document.getElementById('testCanvas');
    const ctx = canvas.getContext('2d');
    let currentTestType = 'number-vs-features';
        
    // Store current test state for redrawing with updated spacing
    let currentTestState = null;

    const SHAPE_TYPES = ['circle', 'square', 'triangle', 'rectangle', 'star'];
    const FRUIT_TYPES = ['apple', 'pear', 'orange', 'banana', 'cherry'];
    const COLOR_OPTIONS = ['#FF6B35', '#4ECDC4', '#FFD93D', '#A855F7', '#3B82F6', '#EF4444'];
    const COUNT_OPTIONS = [2, 3, 4, 5, 6];
    const SHAPE_PATTERN_TYPES = ['solid', 'horizontal-stripes', 'vertical-stripes', 'checkered', 'white-dots'];
    const FRUIT_PATTERN_TYPES = ['horizontal-stripes', 'vertical-stripes', 'checkered', 'white-dots'];

        // Default spacing configuration - now per shape/fruit type
        const DEFAULT_CONFIG = {
            shapes: {
                circle: { gapH: 60, gapV: 60, padding: 45 },
                square: { gapH: 60, gapV: 60, padding: 45 },
                triangle: { gapH: 60, gapV: 60, padding: 45 },
                rectangle: { gapH: 60, gapV: 60, padding: 45 },
                star: { gapH: 60, gapV: 60, padding: 45 }
            },
            fruits: {
                apple: { gapH: 77, gapV: 77, offsetX: 84, offsetY: 84 },
                pear: { gapH: 77, gapV: 77, offsetX: 84, offsetY: 84 },
                orange: { gapH: 70, gapV: 70, offsetX: 84, offsetY: 84 },
                banana: { gapH: 90, gapV: 30, offsetX: 90, offsetY: 90 },
                cherry: { gapH: 70, gapV: 50, offsetX: 84, offsetY: 84 }
            },
            layoutMultipliers: {
                '1x2': { gapH: 1.0, gapV: 1.0 },
                '2x1': { gapH: 1.0, gapV: 1.0 },
                '2x2': { gapH: 1.0, gapV: 1.0 },
                '1x3': { gapH: 1.0, gapV: 1.0 },
                '3x1': { gapH: 1.0, gapV: 1.0 },
                '3x2_5items': { gapH: 0.9, gapV: 0.6 },
                '2x3_5items': { gapH: 0.5, gapV: 1.1 },
                '3x2': { gapH: 1.0, gapV: 0.6 },
                '2x3': { gapH: 1.0, gapV: 1.0 }
            }
        };

        const cloneDefaultConfig = () => JSON.parse(JSON.stringify(DEFAULT_CONFIG));

        let spacingConfig = cloneDefaultConfig();

        function ensureFruitOffsetDefaults(fruitKey) {
            const fruitConfig = spacingConfig.fruits[fruitKey];
            if (!fruitConfig) return;
            const defaultFruit = DEFAULT_CONFIG.fruits[fruitKey] || { offsetX: 0, offsetY: 0 };
            const legacyOffset = typeof fruitConfig.offset === 'number' ? fruitConfig.offset : undefined;
            if (typeof fruitConfig.offsetX !== 'number') {
                fruitConfig.offsetX = typeof legacyOffset === 'number' ? legacyOffset : defaultFruit.offsetX;
            }
            if (typeof fruitConfig.offsetY !== 'number') {
                fruitConfig.offsetY = typeof legacyOffset === 'number' ? legacyOffset : defaultFruit.offsetY;
            }
            delete fruitConfig.offset;
        }

        function applyConfigOverrides(overrides = {}) {
            spacingConfig = cloneDefaultConfig();
            if (overrides.shapes) {
                Object.keys(overrides.shapes).forEach(shape => {
                    if (spacingConfig.shapes[shape]) {
                        Object.assign(spacingConfig.shapes[shape], overrides.shapes[shape]);
                    }
                });
            }
            if (overrides.fruits) {
                Object.keys(overrides.fruits).forEach(fruit => {
                    if (spacingConfig.fruits[fruit]) {
                        Object.assign(spacingConfig.fruits[fruit], overrides.fruits[fruit]);
                        ensureFruitOffsetDefaults(fruit);
                    }
                });
            }
            if (overrides.layoutMultipliers) {
                Object.keys(overrides.layoutMultipliers).forEach(layout => {
                    if (spacingConfig.layoutMultipliers[layout]) {
                        Object.assign(spacingConfig.layoutMultipliers[layout], overrides.layoutMultipliers[layout]);
                    }
                });
            }
            Object.keys(spacingConfig.fruits).forEach(ensureFruitOffsetDefaults);
        }

        // Load configuration from localStorage
        function loadConfig() {
            const saved = localStorage.getItem('spacingConfig');
            if (saved) {
                try {
                    const parsed = JSON.parse(saved);
                    applyConfigOverrides(parsed);
                } catch (e) {
                    console.error('Failed to load config:', e);
                    spacingConfig = cloneDefaultConfig();
                }
            } else {
                spacingConfig = cloneDefaultConfig();
            }
            updateConfigInputs();
        }

        // Save configuration to localStorage
        function saveConfig() {
            localStorage.setItem('spacingConfig', JSON.stringify(spacingConfig));
        }

        // Update config input values
        function updateConfigInputs() {
            // Update shape configs
            ['circle', 'square', 'triangle', 'rectangle', 'star'].forEach(shape => {
                const config = spacingConfig.shapes[shape];
                document.getElementById(`${shape}_gapH`).value = config.gapH;
                document.getElementById(`${shape}_gapV`).value = config.gapV;
                document.getElementById(`${shape}_padding`).value = config.padding;
            });
            
            // Update fruit configs
            FRUIT_TYPES.forEach(fruit => {
                const config = spacingConfig.fruits[fruit];
                document.getElementById(`${fruit}_gapH`).value = config.gapH;
                document.getElementById(`${fruit}_gapV`).value = config.gapV;
                document.getElementById(`${fruit}_offsetX`).value = config.offsetX;
                document.getElementById(`${fruit}_offsetY`).value = config.offsetY;
            });
            
            // Update layout multiplier configs
            ['1x2', '2x1', '2x2', '1x3', '3x1', '3x2_5items', '2x3_5items', '3x2', '2x3'].forEach(layout => {
                const config = spacingConfig.layoutMultipliers[layout];
                document.getElementById(`layout_${layout}_gapH`).value = config.gapH;
                document.getElementById(`layout_${layout}_gapV`).value = config.gapV;
            });
        }

        // Read config from inputs
        function readConfigFromInputs() {
            spacingConfig = {
                shapes: {},
                fruits: {},
                layoutMultipliers: {}
            };
            
            // Read shape configs
            ['circle', 'square', 'triangle', 'rectangle', 'star'].forEach(shape => {
                spacingConfig.shapes[shape] = {
                    gapH: parseFloat(document.getElementById(`${shape}_gapH`).value),
                    gapV: parseFloat(document.getElementById(`${shape}_gapV`).value),
                    padding: parseFloat(document.getElementById(`${shape}_padding`).value)
                };
            });
            
            // Read fruit configs
            FRUIT_TYPES.forEach(fruit => {
                spacingConfig.fruits[fruit] = {
                    gapH: parseFloat(document.getElementById(`${fruit}_gapH`).value),
                    gapV: parseFloat(document.getElementById(`${fruit}_gapV`).value),
                    offsetX: parseFloat(document.getElementById(`${fruit}_offsetX`).value),
                    offsetY: parseFloat(document.getElementById(`${fruit}_offsetY`).value)
                };
            });
            
            // Read layout multiplier configs
            ['1x2', '2x1', '2x2', '1x3', '3x1', '3x2_5items', '2x3_5items', '3x2', '2x3'].forEach(layout => {
                spacingConfig.layoutMultipliers[layout] = {
                    gapH: parseFloat(document.getElementById(`layout_${layout}_gapH`).value),
                    gapV: parseFloat(document.getElementById(`layout_${layout}_gapV`).value)
                };
            });
        }

        // Reset configuration to defaults
        function resetConfig() {
            spacingConfig = cloneDefaultConfig();
            updateConfigInputs();
            saveConfig();
            generateTest();
        }

        // Export configuration as JSON
        function exportConfig() {
            const dataStr = JSON.stringify(spacingConfig, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `spacing-config-${Date.now()}.json`;
            link.click();
            URL.revokeObjectURL(url);
        }

        // Import configuration from JSON
        function importConfig() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'application/json';
            input.onchange = (e) => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        try {
                            const imported = JSON.parse(event.target.result);
                            applyConfigOverrides(imported);
                            updateConfigInputs();
                            saveConfig();
                            generateTest();
                            alert('Configuration imported successfully!');
                        } catch (error) {
                            alert('Failed to import configuration: ' + error.message);
                        }
                    };
                    reader.readAsText(file);
                }
            };
            input.click();
        }

        // Modal control
        const modal = document.getElementById('configModal');
        const configBtn = document.getElementById('configBtn');
        const closeBtn = document.querySelector('.close');
        const saveConfigBtn = document.getElementById('saveConfigBtn');
        const resetConfigBtn = document.getElementById('resetConfigBtn');
        const exportConfigBtn = document.getElementById('exportConfigBtn');
        const importConfigBtn = document.getElementById('importConfigBtn');

        configBtn.onclick = () => {
            modal.classList.add('show');
        };

        closeBtn.onclick = () => {
            modal.classList.remove('show');
        };

        window.onclick = (event) => {
            if (event.target === modal) {
                modal.classList.remove('show');
            }
        };

        saveConfigBtn.onclick = () => {
            readConfigFromInputs();
            saveConfig();
            generateTest(true); // redrawOnly = true, keeps same shapes/fruits/colors
            modal.classList.remove('show');
        };

        resetConfigBtn.onclick = () => {
            if (confirm('Are you sure you want to reset to default spacing values?')) {
                resetConfig();
            }
        };

        exportConfigBtn.onclick = exportConfig;
        importConfigBtn.onclick = importConfig;

        // Tab switching
        document.querySelectorAll('.tab-button').forEach(button => {
            button.addEventListener('click', () => {
                // Remove active class from all tabs and contents
                document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
                
                // Add active class to clicked tab and corresponding content
                button.classList.add('active');
                const tabName = button.dataset.tab;
                document.getElementById(`${tabName}-tab`).classList.add('active');
            });
        });

        // Test type selection
        document.querySelectorAll('.test-type-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.test-type-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentTestType = btn.dataset.type;
            });
        });

        // Fruit drawing functions
        function drawFruit(x, y, size, fruit, pattern, position = 'center') {
            ctx.save();
            
            // Position adjustment based on location (for B2-style requirements)
            let offsetX = 0, offsetY = 0;
            if (position === 'top') offsetY = -size * 0.6;
            else if (position === 'bottom') offsetY = size * 0.6;
            else if (position === 'left') offsetX = -size * 0.6;
            else if (position === 'right') offsetX = size * 0.6;
            
            ctx.translate(x + offsetX, y + offsetY);
            
            // Draw fruit based on type
            switch(fruit) {
                case 'apple':
                    drawApple(0, 0, size, pattern);
                    break;
                case 'pear':
                    drawPear(0, 0, size, pattern);
                    break;
                case 'orange':
                    drawOrange(0, 0, size, pattern);
                    break;
                case 'banana':
                    drawBanana(0, 0, size, pattern);
                    break;
                case 'cherry':
                    drawCherry(0, 0, size, pattern);
                    break;
            }
            
            ctx.restore();
        }

        function drawApple(x, y, size, pattern) {
            const baseColor = '#DC143C'; // Red
            
            ctx.save();
            ctx.translate(x, y);
            
            // Apple body
            ctx.beginPath();
            ctx.ellipse(0, size * 0.1, size * 0.4, size * 0.45, 0, 0, Math.PI * 2);
            ctx.fillStyle = baseColor;
            ctx.fill();
            
            // Leaves and stem
            ctx.fillStyle = '#228B22';
            ctx.beginPath();
            ctx.ellipse(size * 0.15, -size * 0.3, size * 0.15, size * 0.08, Math.PI / 4, 0, Math.PI * 2);
            ctx.fill();
            
            // Apply pattern with proper clipping
            if (pattern) {
                ctx.save();
                ctx.beginPath();
                ctx.ellipse(0, size * 0.1, size * 0.4, size * 0.45, 0, 0, Math.PI * 2);
                ctx.clip();
                applyPattern(pattern, size * 0.9);
                ctx.restore();
            }
            
            ctx.strokeStyle = '#8B0000';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.ellipse(0, size * 0.1, size * 0.4, size * 0.45, 0, 0, Math.PI * 2);
            ctx.stroke();
            
            // Stem
            ctx.fillStyle = '#654321';
            ctx.fillRect(-size * 0.05, -size * 0.4, size * 0.1, size * 0.4);
            
            // Leaf
            ctx.fillStyle = '#228B22';
            ctx.beginPath();
            ctx.ellipse(size * 0.15, -size * 0.3, size * 0.15, size * 0.08, Math.PI / 4, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.restore();
        }

        function drawPear(x, y, size, pattern) {
            const baseColor = '#9ACD32';
            const outlineColor = '#6B8E23';
            const creaseColor = '#D9F47D';
            const scale = 0.7;
            const s = size * scale;
            
            ctx.save();
            ctx.translate(x, y);

            const tracePearBody = () => {
                ctx.beginPath();
                ctx.moveTo(0, s * 0.55);
                ctx.bezierCurveTo(-s * 0.48, s * 0.55, -s * 0.65, s * 0.12, -s * 0.32, -s * 0.38);
                ctx.bezierCurveTo(-s * 0.18, -s * 0.64, -s * 0.05, -s * 0.74, 0, -s * 0.68);
                ctx.bezierCurveTo(s * 0.05, -s * 0.74, s * 0.18, -s * 0.64, s * 0.32, -s * 0.38);
                ctx.bezierCurveTo(s * 0.65, s * 0.12, s * 0.48, s * 0.55, 0, s * 0.55);
                ctx.closePath();
            };

            tracePearBody();
            ctx.fillStyle = baseColor;
            ctx.fill();

            if (pattern) {
                ctx.save();
                tracePearBody();
                ctx.clip();
                applyPattern(pattern, s);
                ctx.restore();
            }

            ctx.strokeStyle = outlineColor;
            ctx.lineWidth = 2;
            tracePearBody();
            ctx.stroke();

            // Leaf and stem
            ctx.fillStyle = '#3A9D41';
            ctx.beginPath();
            ctx.ellipse(s * 0.32, -s * 0.36, s * 0.22, s * 0.11, Math.PI / 10, 0, Math.PI * 2);
            ctx.fill();

            ctx.strokeStyle = '#654321';
            ctx.lineWidth = s * 0.12;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(-s * 0.02, -s * 0.58);
            ctx.lineTo(s * 0.06, -s * 0.7);
            ctx.stroke();
            
            ctx.restore();
        }

        function drawOrange(x, y, size, pattern) {
            const baseColor = '#FFA500'; // Orange
            
            ctx.save();
            ctx.translate(x, y);
            
            // Orange body
            ctx.beginPath();
            ctx.arc(0, 0, size * 0.45, 0, Math.PI * 2);
            ctx.fillStyle = baseColor;
            ctx.fill();
            
            // Apply pattern with proper clipping
            if (pattern) {
                ctx.save();
                ctx.beginPath();
                ctx.arc(0, 0, size * 0.45, 0, Math.PI * 2);
                ctx.clip();
                applyPattern(pattern, size * 0.9);
                ctx.restore();
            }
            
            ctx.strokeStyle = '#FF8C00';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(0, 0, size * 0.45, 0, Math.PI * 2);
            ctx.stroke();
            
            ctx.fillStyle = '#CC7000';
            const dotPositions = [
                [0.2, 0.1], [-0.15, 0.15], [0.1, -0.2], [-0.2, -0.1],
                [0.25, -0.05], [-0.1, -0.25], [0, 0.25], [-0.25, 0.05]
            ];
            dotPositions.forEach(([dx, dy]) => {
                ctx.beginPath();
                ctx.arc(dx * size, dy * size, size * 0.02, 0, Math.PI * 2);
                ctx.fill();
            });
            
            ctx.restore();
        }

        function drawBanana(x, y, size, pattern) {
            const baseColor = '#FFD966'; // Banana yellow
            
            ctx.save();
            ctx.translate(x, y);
            
            // Banana curved shape - more curvy and longer
            ctx.beginPath();
            ctx.moveTo(-size * 0.5, -size * 0.1);
            ctx.bezierCurveTo(-size * 0.4, -size * 0.35, -size * 0.1, -size * 0.4, 0.1 * size, -size * 0.35);
            ctx.bezierCurveTo(size * 0.3, -size * 0.3, size * 0.45, -size * 0.15, size * 0.5, 0.05);
            ctx.bezierCurveTo(size * 0.48, 0.2, size * 0.4, 0.3, size * 0.25, 0.35);
            ctx.bezierCurveTo(size * 0.1, 0.35, -size * 0.1, 0.3, -size * 0.3, 0.2);
            ctx.bezierCurveTo(-size * 0.42, 0.15, -size * 0.48, 0.05, -size * 0.5, -0.1);
            ctx.closePath();
            ctx.fillStyle = baseColor;
            ctx.fill();
            
            // Apply pattern with proper clipping
            if (pattern) {
                ctx.save();
                ctx.beginPath();
                ctx.moveTo(-size * 0.5, -size * 0.1);
                ctx.bezierCurveTo(-size * 0.4, -size * 0.35, -size * 0.1, -size * 0.4, 0.1 * size, -size * 0.35);
                ctx.bezierCurveTo(size * 0.3, -size * 0.3, size * 0.45, -size * 0.15, size * 0.5, 0.05);
                ctx.bezierCurveTo(size * 0.48, 0.2, size * 0.4, 0.3, size * 0.25, 0.35);
                ctx.bezierCurveTo(size * 0.1, 0.35, -size * 0.1, 0.3, -size * 0.3, 0.2);
                ctx.bezierCurveTo(-size * 0.42, 0.15, -size * 0.48, 0.05, -size * 0.5, -0.1);
                ctx.closePath();
                ctx.clip();
                applyPattern(pattern, size);
                ctx.restore();
            }
            
            ctx.strokeStyle = '#DAA520';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(-size * 0.5, -size * 0.1);
            ctx.bezierCurveTo(-size * 0.4, -size * 0.35, -size * 0.1, -size * 0.4, 0.1 * size, -size * 0.35);
            ctx.bezierCurveTo(size * 0.3, -size * 0.3, size * 0.45, -size * 0.15, size * 0.5, 0.05);
            ctx.bezierCurveTo(size * 0.48, 0.2, size * 0.4, 0.3, size * 0.25, 0.35);
            ctx.bezierCurveTo(size * 0.1, 0.35, -size * 0.1, 0.3, -size * 0.3, 0.2);
            ctx.bezierCurveTo(-size * 0.42, 0.15, -size * 0.48, 0.05, -size * 0.5, -0.1);
            ctx.closePath();
            ctx.stroke();
            
            // Stem end
            ctx.fillStyle = '#654321';
            ctx.fillRect(-size * 0.52, -size * 0.15, size * 0.08, size * 0.12);
            
            ctx.restore();
        }

        function drawCherry(x, y, size, pattern) {
    const fruitColor = '#2ECC71';
    const outlineColor = '#1E874B';
    const highlightColor = 'rgba(255,255,255,0.5)';
    const stemColor = '#6B4A2B';
    const leafColor = '#2ECC71';

    ctx.save();
    ctx.translate(x, y);

    const scale = 0.7;
    const radius = size * 0.32 * scale;
    const offsetX = radius * 1.0;
    const offsetY = size * 0.05 * scale;
    // Single cherry
    const cx = 0;
    const cy = offsetY;

    ctx.save();
    ctx.translate(cx, cy);

    ctx.beginPath();
    ctx.arc(0, 0, radius, 0, Math.PI * 2);
    ctx.fillStyle = fruitColor;
    ctx.fill();

    if (pattern) {
        ctx.save();
        ctx.beginPath();
        ctx.arc(0, 0, radius, 0, Math.PI * 2);
        ctx.clip();
        applyPattern(pattern, radius * 2.1);
        ctx.restore();
    }

    ctx.strokeStyle = outlineColor;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(0, 0, radius, 0, Math.PI * 2);
    ctx.stroke();

    // Highlight
    ctx.fillStyle = highlightColor;
    ctx.beginPath();
    ctx.ellipse(-radius * 0.25, -radius * 0.35, radius * 0.18, radius * 0.1, -Math.PI / 6, 0, Math.PI * 2);
    ctx.fill();

    ctx.restore();

    // Stem
    ctx.strokeStyle = stemColor;
    ctx.lineCap = 'round';
    ctx.lineWidth = size * 0.08 * scale;
    ctx.beginPath();
    ctx.moveTo(0, offsetY - radius * 0.9);
    ctx.bezierCurveTo(0, -size * 0.1, 0, -size * 0.2, 0, -size * 0.3);
    ctx.stroke();

    // Stem tip
    ctx.strokeStyle = stemColor;
    ctx.lineWidth = size * 0.08 * scale;
    ctx.beginPath();
    ctx.moveTo(0, -size * 0.3);
    ctx.lineTo(size * 0.01, -size * 0.45);
    ctx.stroke();

    ctx.restore();
}

function applyPattern(pattern, size) {
    if (!pattern || pattern === 'fullrandom' || pattern === 'solid') return;

    // Pattern uses white strokes for high contrast on colored fill
    switch(pattern) {
        case 'horizontal-stripes':
            ctx.fillStyle = 'white';
            for (let y = -size; y < size * 2; y += 20) {
                ctx.fillRect(-size * 2, y, size * 4, 8);
            }
            break;
        case 'vertical-stripes':
            ctx.fillStyle = 'white';
            for (let x = -size; x < size * 2; x += 20) {
                ctx.fillRect(x, -size * 2, 8, size * 4);
            }
            break;
        case 'white-dots':
            ctx.fillStyle = 'white';
            const dotSpacing = 18;
            for (let dx = -size; dx < size; dx += dotSpacing) {
                for (let dy = -size; dy < size; dy += dotSpacing) {
                    ctx.beginPath();
                    ctx.arc(dx, dy, 4, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            break;
        case 'checkered':
            ctx.fillStyle = 'white';
            const squareSize = 14;
            for (let x = -size * 2; x < size * 2; x += squareSize) {
                for (let y = -size * 2; y < size * 2; y += squareSize) {
                    const col = Math.floor((x + size * 2) / squareSize);
                    const row = Math.floor((y + size * 2) / squareSize);
                    if ((col + row) % 2 === 0) {
                        ctx.fillRect(x, y, squareSize, squareSize);
                    }
                }
            }
            break;
    }
}

        // Shape drawing functions
    function drawShape(x, y, size, shape, color, pattern = null, rotation = 0) {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(rotation);

            // Create path for the shape
            ctx.beginPath();
            switch(shape) {
                case 'circle':
                    ctx.arc(0, 0, size/2, 0, Math.PI * 2);
                    break;
                case 'square':
                    ctx.rect(-size/2, -size/2, size, size);
                    break;
                case 'triangle':
                    ctx.moveTo(0, -size/2);
                    ctx.lineTo(size/2, size/2);
                    ctx.lineTo(-size/2, size/2);
                    ctx.closePath();
                    break;
                case 'rectangle':
                    ctx.rect(-size/2, -size/3, size, size * 2/3);
                    break;
                case 'hexagon':
                    for(let i = 0; i < 6; i++) {
                        const angle = (Math.PI / 3) * i;
                        const px = (size/2) * Math.cos(angle);
                        const py = (size/2) * Math.sin(angle);
                        if(i === 0) ctx.moveTo(px, py);
                        else ctx.lineTo(px, py);
                    }
                    ctx.closePath();
                    break;
                case 'star':
                    for(let i = 0; i < 5; i++) {
                        const angle = (Math.PI * 2 / 5) * i - Math.PI/2;
                        const outerX = (size/2) * Math.cos(angle);
                        const outerY = (size/2) * Math.sin(angle);
                        const innerAngle = angle + Math.PI/5;
                        const innerX = (size/4) * Math.cos(innerAngle);
                        const innerY = (size/4) * Math.sin(innerAngle);
                        if(i === 0) ctx.moveTo(outerX, outerY);
                        else ctx.lineTo(outerX, outerY);
                        ctx.lineTo(innerX, innerY);
                    }
                    ctx.closePath();
                    break;
                case 'crescent':
                    ctx.arc(size/6, 0, size/2, 0, Math.PI * 2);
                    ctx.arc(0, 0, size/2, 0, Math.PI * 2, true);
                    break;
            }

            // Fill with base color
            ctx.fillStyle = color;
            ctx.fill();
            
            // Apply pattern overlays (solid means fill only)
            if(pattern && pattern !== 'fullrandom' && pattern !== 'solid') {
                ctx.save();
                ctx.clip();
                applyPattern(pattern, size);
                ctx.restore();
            }

            // Draw outline
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.stroke();

            ctx.restore();
        }

        function arrangeShapes(count, boxX, boxY, boxSize, size, shapeType) {
            const positions = [];
            
            // Get shape-specific configuration
            const shapeConfig = spacingConfig.shapes[shapeType] || spacingConfig.shapes.circle;
            
            // Calculate safe margins - shapes must fit completely within the box
            const shapeRadius = size / 2;
            const safePadding = shapeRadius + shapeConfig.padding;
            const usableWidth = boxSize - (safePadding * 2);
            const usableHeight = boxSize - (safePadding * 2);

            // Determine grid layout based on count for nice arrangements
            let cols, rows;
            if (count === 2) {
                cols = 2;
                rows = 1;
            } else if (count === 3) {
                // Triangle arrangement: 1 on top, 2 on bottom
                cols = 2;
                rows = 2;
            } else if (count === 4) {
                cols = 2;
                rows = 2;
            } else if (count === 5) {
                // Pentagon-like: 2 on top, 3 on bottom
                cols = 3;
                rows = 2;
            } else if (count === 6) {
                cols = 3;
                rows = 2;
            } else {
                cols = Math.ceil(Math.sqrt(count));
                rows = Math.ceil(count / cols);
            }
            
            // Get layout multiplier
            const layoutKey = `${cols}x${rows}`;
            const layoutMultiplier = spacingConfig.layoutMultipliers[layoutKey] || { gapH: 1.0, gapV: 1.0 };
            
            // Apply multipliers to gaps
            const effectiveGapH = shapeConfig.gapH * layoutMultiplier.gapH;
            const effectiveGapV = shapeConfig.gapV * layoutMultiplier.gapV;
            
            // Base position starts at padding boundary
            const baseX = boxX + safePadding;
            const baseY = boxY + safePadding;
            
            // Special arrangements for odd numbers
            if (count === 3) {
                // 1 centered on top, 2 on bottom
                // Top row: 1 shape centered
                const topRowWidth = size;
                const topCenterX = baseX + (usableWidth - topRowWidth) / 2;
                positions.push({
                    x: topCenterX + size / 2,
                    y: baseY + size / 2,
                    rotation: 0
                });
                // Bottom row: 2 shapes
                const bottomRowWidth = size * 2 + effectiveGapH;
                const bottomCenterX = baseX + (usableWidth - bottomRowWidth) / 2;
                positions.push({
                    x: bottomCenterX + size / 2,
                    y: baseY + size + effectiveGapV + size / 2,
                    rotation: 0
                });
                positions.push({
                    x: bottomCenterX + size + effectiveGapH + size / 2,
                    y: baseY + size + effectiveGapV + size / 2,
                    rotation: 0
                });
            } else if (count === 5) {
                // 2 on top, 3 on bottom
                // Top row: 2 shapes
                const topRowWidth = size * 2 + effectiveGapH;
                const topCenterX = baseX + (usableWidth - topRowWidth) / 2;
                positions.push({
                    x: topCenterX + size / 2,
                    y: baseY + size / 2,
                    rotation: 0
                });
                positions.push({
                    x: topCenterX + size + effectiveGapH + size / 2,
                    y: baseY + size / 2,
                    rotation: 0
                });
                // Bottom row: 3 shapes
                const bottomRowWidth = size * 3 + effectiveGapH * 2;
                const bottomCenterX = baseX + (usableWidth - bottomRowWidth) / 2;
                for(let i = 0; i < 3; i++) {
                    positions.push({
                        x: bottomCenterX + (size + effectiveGapH) * i + size / 2,
                        y: baseY + size + effectiveGapV + size / 2,
                        rotation: 0
                    });
                }
            } else {
                // Standard grid for even numbers (2, 4, 6)
                // Center the grid horizontally only, start from top padding
                const gridWidth = size * cols + effectiveGapH * (cols - 1);
                const startX = baseX + (usableWidth - gridWidth) / 2;
                const startY = baseY;
                
                for(let i = 0; i < count; i++) {
                    const col = i % cols;
                    const row = Math.floor(i / cols);
                    
                    const x = startX + (size + effectiveGapH) * col + size / 2;
                    const y = startY + (size + effectiveGapV) * row + size / 2;
                    
                    positions.push({
                        x: x,
                        y: y,
                        rotation: 0
                    });
                }
            }
            
            if (positions.length) {
                const centerX = boxX + boxSize / 2;
                const centerY = boxY + boxSize / 2;
                let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
                positions.forEach(pos => {
                    minX = Math.min(minX, pos.x - size / 2);
                    maxX = Math.max(maxX, pos.x + size / 2);
                    minY = Math.min(minY, pos.y - size / 2);
                    maxY = Math.max(maxY, pos.y + size / 2);
                });
                const currentCenterX = (minX + maxX) / 2;
                const currentCenterY = (minY + maxY) / 2;
                const offsetX = centerX - currentCenterX;
                const offsetY = centerY - currentCenterY;
                positions.forEach(pos => {
                    pos.x += offsetX;
                    pos.y += offsetY;
                });
            }
            
            return positions;
        }
        
        function randomArrangement() {
            // Not used anymore, but kept for compatibility
            return 'grid';
        }

        function drawBox(x, y, size, label) {
            // Fill white background first
            ctx.fillStyle = 'white';
            ctx.fillRect(x, y, size, size);
            
            // Draw border
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 6;
            ctx.strokeRect(x, y, size, size);
            
            // Draw label
            ctx.fillStyle = '#666';
            ctx.font = 'bold 32px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(label, x + size/2, y - 20);
        }

        function randomChoice(arr) {
            return arr[Math.floor(Math.random() * arr.length)];
        }

        function takeRandomValue(pool, fallbackCandidates) {
            if (pool.length > 0) {
                const index = Math.floor(Math.random() * pool.length);
                return pool.splice(index, 1)[0];
            }
            if (fallbackCandidates && fallbackCandidates.length > 0) {
                return randomChoice(fallbackCandidates);
            }
            return null;
        }

        function shuffleArray(arr) {
            const copy = [...arr];
            for (let i = copy.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [copy[i], copy[j]] = [copy[j], copy[i]];
            }
            return copy;
        }

        function buildShapeChoices(targetShape, targetColor, targetCount, targetPattern) {
            const otherShapes = SHAPE_TYPES.filter(shape => shape !== targetShape);
            const otherColors = COLOR_OPTIONS.filter(color => color !== targetColor);
            const otherCounts = COUNT_OPTIONS.filter(count => count !== targetCount);

            const shapePool = [...otherShapes];
            const colorPool = [...otherColors];
            const countPool = [...otherCounts];

            const choices = [];

            choices.push({
                role: 'color',
                shape: takeRandomValue(shapePool, otherShapes),
                color: targetColor,
                count: takeRandomValue(countPool, otherCounts),
                pattern: targetPattern
            });

            choices.push({
                role: 'shape',
                shape: targetShape,
                color: takeRandomValue(colorPool, otherColors),
                count: takeRandomValue(countPool, otherCounts),
                pattern: targetPattern
            });

            choices.push({
                role: 'count',
                shape: takeRandomValue(shapePool, otherShapes),
                color: takeRandomValue(colorPool, otherColors),
                count: targetCount,
                pattern: targetPattern
            });

            choices.push({
                role: 'distractor',
                shape: takeRandomValue(shapePool, otherShapes),
                color: takeRandomValue(colorPool, otherColors),
                count: takeRandomValue(countPool, otherCounts),
                pattern: targetPattern
            });

            return shuffleArray(choices);
        }

        function randomColor() {
            return randomChoice(COLOR_OPTIONS);
        }

        function randomShape() {
            return randomChoice(SHAPE_TYPES);
        }

        function randomPattern() {
            return randomChoice(SHAPE_PATTERN_TYPES);
        }

        function randomFruit() {
            return randomChoice(FRUIT_TYPES);
        }

    function buildFruitChoices(targetFruit, targetPattern, targetCount, targetGroupPosition, remainingPositions) {
            // Fruit roles with explicit constraints:
            // - pattern: same pattern only ‚Üí same pattern, different fruit, different location, different count
            // - location: same location only ‚Üí same location, different fruit, different count, different pattern
            // - count: same count only ‚Üí same count, different fruit, different location, different pattern
            // - distractor: different in pattern, location, and count but SAME fruit

            const otherCounts = COUNT_OPTIONS.filter(count => count !== targetCount);
            const countPool = [...otherCounts];

            const overlayPatterns = FRUIT_PATTERN_TYPES;
            const otherPatterns = overlayPatterns.filter(p => p !== targetPattern);

            // Fruit spatial locations: only use the four edge positions.
            // We receive the three non-target positions for this trial and
            // assign them one-to-one to pattern/count/distractor so that
            // each trial uses all four locations exactly once.
            const allPositions = ['top', 'bottom', 'left', 'right'];
            const baseRemaining = Array.isArray(remainingPositions) && remainingPositions.length === 3
                ? remainingPositions
                : allPositions.filter(p => p !== targetGroupPosition);
            const positionPool = [...baseRemaining];

            const otherFruits = FRUIT_TYPES.filter(fruit => fruit !== targetFruit);
            const fruitPool = [...otherFruits];

            const choices = [];

            // 1. Pattern-only match: same pattern, different fruit/count/location
            const patternLocation = takeRandomValue(positionPool, baseRemaining);
            choices.push({
                role: 'pattern',
                fruit: takeRandomValue(fruitPool, otherFruits),
                pattern: targetPattern,
                count: takeRandomValue(countPool, otherCounts),
                location: patternLocation
            });

            // 2. Location-only match: same location, different fruit/pattern/count
            const locationRolePattern = takeRandomValue(otherPatterns, overlayPatterns);
            choices.push({
                role: 'location',
                fruit: takeRandomValue(fruitPool, otherFruits),
                pattern: locationRolePattern,
                count: takeRandomValue(countPool, otherCounts),
                location: targetGroupPosition
            });

            // 3. Count-only match: same count, different fruit/pattern/location
            const countRolePattern = takeRandomValue(otherPatterns, overlayPatterns);
            const countRoleLocation = takeRandomValue(positionPool, baseRemaining);
            choices.push({
                role: 'count',
                fruit: takeRandomValue(fruitPool, otherFruits),
                pattern: countRolePattern,
                count: targetCount,
                location: countRoleLocation
            });

            // 4. Full distractor: different fruit, pattern, location, and count
            const distractorPattern = takeRandomValue(otherPatterns, overlayPatterns);
            const distractorCount = takeRandomValue(countPool, otherCounts);
            const distractorLocation = takeRandomValue(positionPool, baseRemaining);
            choices.push({
                role: 'distractor',
                fruit: takeRandomValue(fruitPool, otherFruits),
                pattern: distractorPattern,
                count: distractorCount,
                location: distractorLocation
            });

            return shuffleArray(choices);
        }

        function generateTest(redrawOnly = false) {
            // Always use horizontal layout
            canvas.width = 2400;
            canvas.height = 800;
            
            // Clear canvas with white background
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Scale everything up for better resolution
            const boxSize = 380;
            const margin = 60;
            const shapeSize = 70;

            // Get target parameters
            const targetType = document.getElementById('targetType').value;
            const targetCount = parseInt(document.getElementById('targetCount').value);
            const targetPattern = document.getElementById('targetPattern').value;
            
            const boxY = 200;
            
            // If redrawOnly and we have a saved state, use it
            if (redrawOnly && currentTestState && 
                currentTestState.targetType === targetType &&
                currentTestState.targetCount === targetCount &&
                currentTestState.targetPattern === targetPattern) {
                // Redraw using saved state
                redrawTestFromState(currentTestState, boxSize, margin, shapeSize, boxY);
                return;
            }

            if (targetType === 'shape') {
                // Original shape-based logic
                const targetShape = document.getElementById('targetShape').value;
                const targetColor = document.getElementById('targetColor').value;

                const choices = buildShapeChoices(targetShape, targetColor, targetCount, targetPattern);
                let correctIndex = choices.findIndex(choice => choice.role === 'shape');
                if (correctIndex === -1) {
                    correctIndex = 0;
                }

                // Draw target
                const targetX = margin;
                drawBox(targetX, boxY, boxSize, 'ÁõÆÊ†á');
                const targetPositions = arrangeShapes(targetCount, targetX, boxY, boxSize, shapeSize, targetShape);
                targetPositions.forEach(pos => {
                    drawShape(pos.x, pos.y, shapeSize, targetShape, targetColor, targetPattern, pos.rotation);
                });

                // Draw choices
                for(let i = 0; i < 4; i++) {
                    const x = margin + (boxSize + margin) * (i + 1);
                    drawBox(x, boxY, boxSize, `${i + 1}`);
                    const positions = arrangeShapes(choices[i].count, x, boxY, boxSize, shapeSize, choices[i].shape);
                    positions.forEach(pos => {
                        drawShape(pos.x, pos.y, shapeSize, choices[i].shape, choices[i].color, choices[i].pattern, pos.rotation);
                    });
                }

                console.log(`Same-shape option: ${correctIndex + 1}`);
                console.log('Option roles:', choices.map((choice, idx) => `${idx + 1}: ${choice.role}`).join(', '));
                
                // Save test state for redrawing
                currentTestState = {
                    targetType: 'shape',
                    targetCount,
                    targetPattern,
                    targetShape,
                    targetColor,
                    choices,
                    correctIndex
                };
                
            } else if (targetType === 'fruit') {
                // Fruit-based logic with pattern/location/count/distractor roles and explicit fruit constraints
                const targetFruit = document.getElementById('targetFruit').value;

                // Positions for spatial manipulation (exclude center for fruit tests)
                const allPositions = ['top', 'bottom', 'left', 'right'];
                const targetGroupPosition = randomChoice(allPositions);
                const remainingPositions = allPositions.filter(p => p !== targetGroupPosition);

                // Handle fullrandom pattern - ensure all 4 patterns appear
                let targetPatternValue = targetPattern;
                let choices;

                if (targetPattern === 'fullrandom') {
                    // In fullrandom, choose a concrete target pattern first
                    targetPatternValue = randomChoice(FRUIT_PATTERN_TYPES);
                    choices = buildFruitChoices(targetFruit, targetPatternValue, targetCount, targetGroupPosition, remainingPositions);
                } else {
                    // Fixed overlay pattern
                    targetPatternValue = targetPattern;
                    choices = buildFruitChoices(targetFruit, targetPatternValue, targetCount, targetGroupPosition, remainingPositions);
                }

                // Identify the same-count role as the correct answer
                const correctIndex = choices.findIndex(c => c.role === 'count');

                // Arrange fruits in a compact group, then shift entire group based on position
                const getPositionsForCount = (count, centerX, centerY, boxSize, groupPosition, fruitType) => {
                    const positions = [];
                    // Get fruit-specific configuration
                    const fruitConfig = spacingConfig.fruits[fruitType] || spacingConfig.fruits.apple;
                    
                    // Determine layout for multiplier selection
                    let layoutKey = '1x1';
                    let cols = 1, rows = 1;
                    
                    if (count === 2) {
                        layoutKey = '1x2';
                        cols = 2; rows = 1;
                    } else if (count === 3) {
                        layoutKey = '2x2'; // Triangle arrangement uses 2x2 space
                        cols = 2; rows = 2;
                    } else if (count === 4) {
                        layoutKey = '2x2';
                        cols = 2; rows = 2;
                    } else if (count === 5) {
                        const useColumns = groupPosition === 'left' || groupPosition === 'right';
                        layoutKey = useColumns ? '2x3_5items' : '3x2_5items';
                        cols = useColumns ? 2 : 3;
                        rows = useColumns ? 3 : 2;
                    } else if (count === 6) {
                        const useVertical = groupPosition === 'left' || groupPosition === 'right';
                        layoutKey = useVertical ? '2x3' : '3x2';
                        cols = useVertical ? 2 : 3;
                        rows = useVertical ? 3 : 2;
                    }
                    
                    // Get layout multiplier
                    const layoutMultiplier = spacingConfig.layoutMultipliers[layoutKey] || { gapH: 1.0, gapV: 1.0 };
                    
                    // Apply multipliers to base gaps
                    const spacingH = fruitConfig.gapH * layoutMultiplier.gapH;
                    const spacingV = fruitConfig.gapV * layoutMultiplier.gapV;
                    
                    // First, arrange fruits in a compact group around origin (0,0)
                    let relativePositions = [];
                    switch (count) {
                        case 1:
                            relativePositions.push({ x: 0, y: 0 });
                            break;
                        case 2:
                            relativePositions.push({ x: -spacingH * 0.6, y: 0 });
                            relativePositions.push({ x: spacingH * 0.6, y: 0 });
                            break;
                        case 3:
                            relativePositions.push({ x: 0, y: -spacingV * 0.6 });
                            relativePositions.push({ x: -spacingH * 0.6, y: spacingV * 0.6 });
                            relativePositions.push({ x: spacingH * 0.6, y: spacingV * 0.6 });
                            break;
                        case 4:
                            relativePositions.push({ x: -spacingH * 0.6, y: -spacingV * 0.6 });
                            relativePositions.push({ x: spacingH * 0.6, y: -spacingV * 0.6 });
                            relativePositions.push({ x: -spacingH * 0.6, y: spacingV * 0.6 });
                            relativePositions.push({ x: spacingH * 0.6, y: spacingV * 0.6 });
                            break;
                        case 5: {
                            const useColumns = groupPosition === 'left' || groupPosition === 'right';
                            if (useColumns) {
                                // Column-based layout for left/right positions: 2 columns (2|3 or 3|2)
                                const twoLeft = Math.random() < 0.5;
                                const colOffset = spacingH * 1.0;
                                const rowOffset = spacingV * 0.95;
                                if (twoLeft) {
                                    // Left column: 2 fruits (vertically centered)
                                    relativePositions.push({ x: -colOffset, y: -rowOffset * 0.5 });
                                    relativePositions.push({ x: -colOffset, y: rowOffset * 0.5 });
                                    // Right column: 3 fruits
                                    relativePositions.push({ x: colOffset, y: -rowOffset });
                                    relativePositions.push({ x: colOffset, y: 0 });
                                    relativePositions.push({ x: colOffset, y: rowOffset });
                                } else {
                                    // Left column: 3 fruits
                                    relativePositions.push({ x: -colOffset, y: -rowOffset });
                                    relativePositions.push({ x: -colOffset, y: 0 });
                                    relativePositions.push({ x: -colOffset, y: rowOffset });
                                    // Right column: 2 fruits (vertically centered)
                                    relativePositions.push({ x: colOffset, y: -rowOffset * 0.5 });
                                    relativePositions.push({ x: colOffset, y: rowOffset * 0.5 });
                                }
                            } else {
                                // Row-based layout for top/bottom positions: 2 rows (2-3 or 3-2)
                                const twoTop = Math.random() < 0.5;
                                const rowOffset = spacingV * 0.9;
                                const colOffset = spacingH * 1.0;
                                if (twoTop) {
                                    // Top row: 2
                                    relativePositions.push({ x: -colOffset * 0.5, y: -rowOffset });
                                    relativePositions.push({ x: colOffset * 0.5, y: -rowOffset });
                                    // Bottom row: 3
                                    relativePositions.push({ x: -colOffset, y: rowOffset });
                                    relativePositions.push({ x: 0, y: rowOffset });
                                    relativePositions.push({ x: colOffset, y: rowOffset });
                                } else {
                                    // Top row: 3
                                    relativePositions.push({ x: -colOffset, y: -rowOffset });
                                    relativePositions.push({ x: 0, y: -rowOffset });
                                    relativePositions.push({ x: colOffset, y: -rowOffset });
                                    // Bottom row: 2
                                    relativePositions.push({ x: -colOffset * 0.5, y: rowOffset });
                                    relativePositions.push({ x: colOffset * 0.5, y: rowOffset });
                                }
                            }
                            break;
                        }
                        case 6: {
                            const useVertical = groupPosition === 'left' || groupPosition === 'right';
                            if (useVertical) {
                                // 2 columns x 3 rows (taller layout)
                                const colOffset = spacingH * 1.05;
                                const rowOffset = spacingV * 0.95;
                                const columns = [-colOffset * 0.5, colOffset * 0.5];
                                const rows = [-rowOffset, 0, rowOffset];
                                columns.forEach(x => {
                                    rows.forEach(y => {
                                        relativePositions.push({ x, y });
                                    });
                                });
                            } else {
                                // 3 columns x 2 rows (wider layout)
                                const colOffset = spacingH * 1.0;
                                const rowOffset = spacingV * 0.9;
                                const columns = [-colOffset, 0, colOffset];
                                const rows = [-rowOffset, rowOffset];
                                columns.forEach(x => {
                                    rows.forEach(y => {
                                        relativePositions.push({ x, y });
                                    });
                                });
                            }
                            break;
                        }
                        default:
                            // Fallback: distribute in simple grid
                            const cols = Math.ceil(Math.sqrt(count));
                            const rows = Math.ceil(count / cols);
                            for (let i = 0; i < count; i++) {
                                const col = i % cols;
                                const row = Math.floor(i / cols);
                                const offsetX = (col - (cols - 1) / 2) * spacingH;
                                const offsetY = (row - (rows - 1) / 2) * spacingV;
                                relativePositions.push({ x: offsetX, y: offsetY });
                            }
                    }
                    
                    // Now shift the ENTIRE group based on groupPosition
                    const offsetX = typeof fruitConfig.offsetX === 'number' ? fruitConfig.offsetX : 0;
                    const offsetY = typeof fruitConfig.offsetY === 'number' ? fruitConfig.offsetY : 0;
                    let groupOffsetX = 0, groupOffsetY = 0;
                    
                    switch(groupPosition) {
                        case 'top':
                            groupOffsetY = -offsetY;
                            break;
                        case 'bottom':
                            groupOffsetY = offsetY;
                            break;
                        case 'left':
                            groupOffsetX = -offsetX;
                            break;
                        case 'right':
                            groupOffsetX = offsetX;
                            break;
                        case 'center':
                        default:
                            // No offset
                            break;
                    }
                    
                    // Apply group offset to all fruits
                    relativePositions.forEach(pos => {
                        positions.push({
                            x: centerX + pos.x + groupOffsetX,
                            y: centerY + pos.y + groupOffsetY
                        });
                    });
                    
                    return positions;
                };

                // Draw target
                const targetX = margin;
                drawBox(targetX, boxY, boxSize, 'ÁõÆÊ†á');
                const targetCenterX = targetX + boxSize / 2;
                const targetCenterY = boxY + boxSize / 2;
                const targetPositions = getPositionsForCount(targetCount, targetCenterX, targetCenterY, boxSize, targetGroupPosition, targetFruit);
                targetPositions.forEach(pos => {
                    drawFruit(pos.x, pos.y, shapeSize, targetFruit, targetPatternValue, 'center');
                });

                // Draw choices with positioned fruits
                for(let i = 0; i < 4; i++) {
                    const x = margin + (boxSize + margin) * (i + 1);
                    drawBox(x, boxY, boxSize, `${i + 1}`);
                    const centerX = x + boxSize / 2;
                    const centerY = boxY + boxSize / 2;
                    const fruitPositions = getPositionsForCount(choices[i].count, centerX, centerY, boxSize, choices[i].location, choices[i].fruit);
                    fruitPositions.forEach(pos => {
                        drawFruit(pos.x, pos.y, shapeSize, choices[i].fruit, choices[i].pattern, 'center');
                    });
                }

                console.log(`Same-count option (fruit): ${correctIndex + 1}`);
                console.log('Fruit option roles:', choices.map((choice, idx) => `${idx + 1}: ${choice.role} (fruit=${choice.fruit}, pattern=${choice.pattern}, location=${choice.location}, count=${choice.count})`).join(' | '));
                if (targetPattern === 'fullrandom') {
                    console.log(`Full Random Mode - Target: ${targetPatternValue}`);
                    console.log('Choice patterns:', choices.map((c, i) => `${i+1}: ${c.pattern}`).join(', '));
                } else {
                    console.log(`All fruits use pattern: ${targetPatternValue}`);
                }

                // Save test state for redrawing
                currentTestState = {
                    targetType: 'fruit',
                    targetCount,
                    targetPattern,
                    targetFruit,
                    targetPatternValue,
                    targetGroupPosition,
                    choices,
                    correctIndex
                };
            }
        }
        
        function redrawTestFromState(state, boxSize, margin, shapeSize, boxY) {
            // Redraw the test using saved state with updated spacing configuration
            if (state.targetType === 'shape') {
                // Draw target
                const targetX = margin;
                drawBox(targetX, boxY, boxSize, 'ÁõÆÊ†á');
                const targetPositions = arrangeShapes(state.targetCount, targetX, boxY, boxSize, shapeSize, state.targetShape);
                targetPositions.forEach(pos => {
                    drawShape(pos.x, pos.y, shapeSize, state.targetShape, state.targetColor, state.targetPattern, pos.rotation);
                });

                // Draw choices
                for(let i = 0; i < 4; i++) {
                    const x = margin + (boxSize + margin) * (i + 1);
                    drawBox(x, boxY, boxSize, `${i + 1}`);
                    const positions = arrangeShapes(state.choices[i].count, x, boxY, boxSize, shapeSize, state.choices[i].shape);
                    positions.forEach(pos => {
                        drawShape(pos.x, pos.y, shapeSize, state.choices[i].shape, state.choices[i].color, state.choices[i].pattern, pos.rotation);
                    });
                }
            } else if (state.targetType === 'fruit') {
                const getPositionsForCount = (count, centerX, centerY, boxSize, groupPosition, fruitType) => {
                    const positions = [];
                    // Get fruit-specific configuration
                    const fruitConfig = spacingConfig.fruits[fruitType] || spacingConfig.fruits.apple;
                    
                    // Determine layout for multiplier selection
                    let layoutKey = '1x1';
                    let cols = 1, rows = 1;
                    
                    if (count === 2) {
                        layoutKey = '1x2';
                        cols = 2; rows = 1;
                    } else if (count === 3) {
                        layoutKey = '2x2'; // Triangle arrangement uses 2x2 space
                        cols = 2; rows = 2;
                    } else if (count === 4) {
                        layoutKey = '2x2';
                        cols = 2; rows = 2;
                    } else if (count === 5) {
                        const useColumns = groupPosition === 'left' || groupPosition === 'right';
                        layoutKey = useColumns ? '2x3_5items' : '3x2_5items';
                        cols = useColumns ? 2 : 3;
                        rows = useColumns ? 3 : 2;
                    } else if (count === 6) {
                        const useVertical = groupPosition === 'left' || groupPosition === 'right';
                        layoutKey = useVertical ? '2x3' : '3x2';
                        cols = useVertical ? 2 : 3;
                        rows = useVertical ? 3 : 2;
                    }
                    
                    // Get layout multiplier
                    const layoutMultiplier = spacingConfig.layoutMultipliers[layoutKey] || { gapH: 1.0, gapV: 1.0 };
                    
                    // Apply multipliers to base gaps
                    const spacingH = fruitConfig.gapH * layoutMultiplier.gapH;
                    const spacingV = fruitConfig.gapV * layoutMultiplier.gapV;
                    
                    // First, arrange fruits in a compact group around origin (0,0)
                    let relativePositions = [];
                    switch (count) {
                        case 1:
                            relativePositions.push({ x: 0, y: 0 });
                            break;
                        case 2:
                            relativePositions.push({ x: -spacingH * 0.6, y: 0 });
                            relativePositions.push({ x: spacingH * 0.6, y: 0 });
                            break;
                        case 3:
                            relativePositions.push({ x: 0, y: -spacingV * 0.6 });
                            relativePositions.push({ x: -spacingH * 0.6, y: spacingV * 0.6 });
                            relativePositions.push({ x: spacingH * 0.6, y: spacingV * 0.6 });
                            break;
                        case 4:
                            relativePositions.push({ x: -spacingH * 0.6, y: -spacingV * 0.6 });
                            relativePositions.push({ x: spacingH * 0.6, y: -spacingV * 0.6 });
                            relativePositions.push({ x: -spacingH * 0.6, y: spacingV * 0.6 });
                            relativePositions.push({ x: spacingH * 0.6, y: spacingV * 0.6 });
                            break;
                        case 5: {
                            const useColumns = groupPosition === 'left' || groupPosition === 'right';
                            if (useColumns) {
                                // Column-based layout for left/right positions: 2 columns (2|3 or 3|2)
                                const twoLeft = Math.random() < 0.5;
                                const colOffset = spacingH * 1.0;
                                const rowOffset = spacingV * 0.95;
                                if (twoLeft) {
                                    // Left column: 2 fruits (vertically centered)
                                    relativePositions.push({ x: -colOffset, y: -rowOffset * 0.5 });
                                    relativePositions.push({ x: -colOffset, y: rowOffset * 0.5 });
                                    // Right column: 3 fruits
                                    relativePositions.push({ x: colOffset, y: -rowOffset });
                                    relativePositions.push({ x: colOffset, y: 0 });
                                    relativePositions.push({ x: colOffset, y: rowOffset });
                                } else {
                                    // Left column: 3 fruits
                                    relativePositions.push({ x: -colOffset, y: -rowOffset });
                                    relativePositions.push({ x: -colOffset, y: 0 });
                                    relativePositions.push({ x: -colOffset, y: rowOffset });
                                    // Right column: 2 fruits (vertically centered)
                                    relativePositions.push({ x: colOffset, y: -rowOffset * 0.5 });
                                    relativePositions.push({ x: colOffset, y: rowOffset * 0.5 });
                                }
                            } else {
                                // Row-based layout for top/bottom positions: 2 rows (2-3 or 3-2)
                                const twoTop = Math.random() < 0.5;
                                const rowOffset = spacingV * 0.9;
                                const colOffset = spacingH * 1.0;
                                if (twoTop) {
                                    // Top row: 2
                                    relativePositions.push({ x: -colOffset * 0.5, y: -rowOffset });
                                    relativePositions.push({ x: colOffset * 0.5, y: -rowOffset });
                                    // Bottom row: 3
                                    relativePositions.push({ x: -colOffset, y: rowOffset });
                                    relativePositions.push({ x: 0, y: rowOffset });
                                    relativePositions.push({ x: colOffset, y: rowOffset });
                                } else {
                                    // Top row: 3
                                    relativePositions.push({ x: -colOffset, y: -rowOffset });
                                    relativePositions.push({ x: 0, y: -rowOffset });
                                    relativePositions.push({ x: colOffset, y: -rowOffset });
                                    // Bottom row: 2
                                    relativePositions.push({ x: -colOffset * 0.5, y: rowOffset });
                                    relativePositions.push({ x: colOffset * 0.5, y: rowOffset });
                                }
                            }
                            break;
                        }
                        case 6: {
                            const useVertical = groupPosition === 'left' || groupPosition === 'right';
                            if (useVertical) {
                                // 2 columns x 3 rows (taller layout)
                                const colOffset = spacingH * 1.05;
                                const rowOffset = spacingV * 0.95;
                                const columns = [-colOffset * 0.5, colOffset * 0.5];
                                const rows = [-rowOffset, 0, rowOffset];
                                columns.forEach(x => {
                                    rows.forEach(y => {
                                        relativePositions.push({ x, y });
                                    });
                                });
                            } else {
                                // 3 columns x 2 rows (wider layout)
                                const colOffset = spacingH * 1.0;
                                const rowOffset = spacingV * 0.9;
                                const columns = [-colOffset, 0, colOffset];
                                const rows = [-rowOffset, rowOffset];
                                columns.forEach(x => {
                                    rows.forEach(y => {
                                        relativePositions.push({ x, y });
                                    });
                                });
                            }
                            break;
                        }
                        default:
                            // Fallback: distribute in simple grid
                            const cols = Math.ceil(Math.sqrt(count));
                            const rows = Math.ceil(count / cols);
                            for (let i = 0; i < count; i++) {
                                const col = i % cols;
                                const row = Math.floor(i / cols);
                                const offsetX = (col - (cols - 1) / 2) * spacingH;
                                const offsetY = (row - (rows - 1) / 2) * spacingV;
                                relativePositions.push({ x: offsetX, y: offsetY });
                            }
                    }
                    
                    // Now shift the ENTIRE group based on groupPosition
                    const offsetX = typeof fruitConfig.offsetX === 'number' ? fruitConfig.offsetX : 0;
                    const offsetY = typeof fruitConfig.offsetY === 'number' ? fruitConfig.offsetY : 0;
                    let groupOffsetX = 0, groupOffsetY = 0;
                    
                    switch(groupPosition) {
                        case 'top':
                            groupOffsetY = -offsetY;
                            break;
                        case 'bottom':
                            groupOffsetY = offsetY;
                            break;
                        case 'left':
                            groupOffsetX = -offsetX;
                            break;
                        case 'right':
                            groupOffsetX = offsetX;
                            break;
                        case 'center':
                        default:
                            // No offset
                            break;
                    }
                    
                    // Apply group offset to all fruits
                    relativePositions.forEach(pos => {
                        positions.push({
                            x: centerX + pos.x + groupOffsetX,
                            y: centerY + pos.y + groupOffsetY
                        });
                    });
                    
                    return positions;
                };
                
                // Draw target
                const targetX = margin;
                drawBox(targetX, boxY, boxSize, 'ÁõÆÊ†á');
                const targetCenterX = targetX + boxSize / 2;
                const targetCenterY = boxY + boxSize / 2;
                const targetPositions = getPositionsForCount(state.targetCount, targetCenterX, targetCenterY, boxSize, state.targetGroupPosition, state.targetFruit);
                targetPositions.forEach(pos => {
                    drawFruit(pos.x, pos.y, shapeSize, state.targetFruit, state.targetPatternValue, 'center');
                });

                // Draw choices with positioned fruits
                for(let i = 0; i < 4; i++) {
                    const x = margin + (boxSize + margin) * (i + 1);
                    drawBox(x, boxY, boxSize, `${i + 1}`);
                    const centerX = x + boxSize / 2;
                    const centerY = boxY + boxSize / 2;
                    
                    const fruitPositions = getPositionsForCount(state.choices[i].count, centerX, centerY, boxSize, state.choices[i].position, state.choices[i].fruit);
                    fruitPositions.forEach(pos => {
                        drawFruit(pos.x, pos.y, shapeSize, state.choices[i].fruit, state.choices[i].pattern, 'center');
                    });
                }
            }
        }

        function downloadTest() {
            const link = document.createElement('a');
            link.download = `attention-to-number-test-${Date.now()}.png`;
            link.href = canvas.toDataURL();
            link.click();
        }

        // Preview update functions
        function updateShapePreview() {
            const previewCanvas = document.getElementById('shapePreview');
            const previewCtx = previewCanvas.getContext('2d');
            const shape = document.getElementById('targetShape').value;
            const color = document.getElementById('targetColor').value;
            
            previewCtx.clearRect(0, 0, 35, 35);
            drawShape(17.5, 17.5, 28, shape, color, null, 0);
        }

        function updateColorPreview() {
            const previewCanvas = document.getElementById('colorPreview');
            const previewCtx = previewCanvas.getContext('2d');
            const color = document.getElementById('targetColor').value;
            
            previewCtx.clearRect(0, 0, 35, 35);
            previewCtx.fillStyle = color;
            previewCtx.fillRect(2, 2, 31, 31);
            previewCtx.strokeStyle = '#333';
            previewCtx.lineWidth = 2;
            previewCtx.strokeRect(2, 2, 31, 31);
        }

        function updatePatternPreview() {
            const previewCanvas = document.getElementById('patternPreview');
            const previewCtx = previewCanvas.getContext('2d');
            const pattern = document.getElementById('targetPattern').value;
            const color = document.getElementById('targetColor').value;
            
            previewCtx.clearRect(0, 0, 35, 35);
            
            if (pattern === 'fullrandom') {
                // Show mixed pattern preview
                previewCtx.fillStyle = '#888';
                previewCtx.font = '20px Arial';
                previewCtx.textAlign = 'center';
                previewCtx.textBaseline = 'middle';
                previewCtx.fillText('üé≤', 17.5, 17.5);
            } else {
                drawShape(17.5, 17.5, 28, 'square', color, pattern, 0);
            }
        }

        function updateFruitPreview() {
            const previewCanvas = document.getElementById('fruitPreview');
            const previewCtx = previewCanvas.getContext('2d');
            const fruit = document.getElementById('targetFruit').value;
            let pattern = document.getElementById('targetPattern').value;
            
            previewCtx.clearRect(0, 0, 35, 35);
            
            // For fullrandom, show the first overlay as preview
            if (pattern === 'fullrandom') {
                pattern = FRUIT_PATTERN_TYPES[0];
            }
            
            // Draw fruit directly with previewCtx
            const savedCtx = ctx;
            window.ctx = previewCtx; // Temporarily set global ctx
            drawFruit(17.5, 17.5, 24, fruit, pattern, 'center');
            window.ctx = savedCtx; // Restore
        }

        function toggleTargetType() {
            const targetType = document.getElementById('targetType').value;
            const shapeGroup = document.getElementById('shapeGroup');
            const fruitGroup = document.getElementById('fruitGroup');
            const colorGroup = document.getElementById('colorGroup');
            const fullrandomOption = document.getElementById('fullrandomOption');
            const solidPatternOption = document.getElementById('solidPatternOption');
            const targetPattern = document.getElementById('targetPattern');
            
            if (targetType === 'shape') {
                shapeGroup.classList.remove('hidden');
                fruitGroup.classList.add('hidden');
                colorGroup.classList.remove('hidden');
                fullrandomOption.classList.add('hidden');
                solidPatternOption.classList.remove('hidden');
                solidPatternOption.disabled = false;
                // Reset to solid if it was fullrandom
                if (targetPattern.value === 'fullrandom') {
                    targetPattern.value = 'solid';
                }
                updatePatternPreview();
            } else {
                shapeGroup.classList.add('hidden');
                fruitGroup.classList.remove('hidden');
                colorGroup.classList.add('hidden'); // Hide color for fruits
                fullrandomOption.classList.remove('hidden');
                solidPatternOption.classList.add('hidden');
                solidPatternOption.disabled = true;
                // Set default to fullrandom for fruits
                targetPattern.value = 'fullrandom';
                updatePatternPreview();
                updateFruitPreview();
            }
        }

        // Add event listeners for preview updates
        document.getElementById('targetType').addEventListener('change', () => {
            toggleTargetType();
            generateTest();
        });
        
        document.getElementById('targetShape').addEventListener('change', () => {
            updateShapePreview();
            updatePatternPreview();
        });
        document.getElementById('targetColor').addEventListener('change', () => {
            updateShapePreview();
            updateColorPreview();
            updatePatternPreview();
        });
        document.getElementById('targetPattern').addEventListener('change', () => {
            updatePatternPreview();
            if (document.getElementById('targetType').value === 'fruit') {
                updateFruitPreview();
            }
        });
        
        document.getElementById('targetFruit').addEventListener('change', updateFruitPreview);

        document.getElementById('generateBtn').addEventListener('click', () => generateTest());
        document.getElementById('downloadBtn').addEventListener('click', downloadTest);

        // Load configuration and generate initial test
        loadConfig();
        toggleTargetType();
        updateShapePreview();
        updateColorPreview();
        updatePatternPreview();
        updateFruitPreview();
        generateTest();
    </script>
</body>
</html>
